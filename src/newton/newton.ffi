--//
--//
--//
--//
--//	Wirth FFI description for Noisy. This is a replacement for the old Newton FFI
--//	(see the comment at the bottom of issue #20 and #317)
--//
--//
--//
--//



--//
--//
--//
--//
--//
--//	FIRST()s
--//
--//
--//
--//







--//		numericConst			::=	integerConst | realConst .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		newtonDescription		::=	ruleList .
production kNewtonIrNodeType_P:					firstset = {
									}

--//		ruleList			::=	{rule} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		rule				::=	constantDefinition | invariantDefinition | baseSignalDefinition | sensorDefinition .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		constantDefinition		::=	identifier ":" "constant" "=" numericConst [unitExpression] ";" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		invariantDefinition		::=	identifier ":" "invariant" parameterTuple  "=" "{" constraintList "}" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		baseSignalDefinition		::=	identifier ":" "signal" [subdimensionTuple] "=" "{" [nameStatement] symbolStatement derivationStatement "}" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		sensorDefinition		::=	identifier ":" "sensor" parameterTuple = "{" sensorPropertyList "}" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		nameStatement			::=	"name" "=" stringConst languageSetting ";" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		symbolStatement			::=	"symbol" "=" identifier ";" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		derivationStatement		::=	"derivation" "=" ("none" | quantityExpression) ";" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		subdimensionTuple		::=	"(" identifier ":" numericConst "to" numericConst ")" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		parameterTuple			::=	"(" parameter {"," parameter} ")" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		parameter			::=	identifier ":" identifier .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		constraintList			::=	constraint {"," constraint} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		constraint			::=	quantityExpression comparisonOperator quantityExpression .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		quantityExpression		::=	quantityTerm {lowPrecedenceOperator quantityTerm} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		quantityTerm			::=	[unaryMinus] quantityFactor {midPrecedenceOperator quantityFactor} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		quantityFactor			::=	quantity								|
--//							quantity [highPrecedenceOperator quantityExpression]			|
--//								timeOperator {timeOperator} quantityExpression			|
--//								"(" quantityExpression ")" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		quantity			::=	numericConst | (identifier {"@" numericConst}) .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		lowPrecedenceOperator		::=	"+" | "-" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		midPrecedenceOperator		::=	"*" | "/" | vectorOp .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		highPrecedenceOperator		::=	"**" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		vectorOp			::=	"dot" | "cross" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		timeOperator			::=	"derivative" | "integral" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		comparisonOperator		::=	"o<" | "~" | "<" | "<=" | ">" | ">=" | "==" | "<->" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		unaryMinus			::=	"-" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		languageSetting			::=	"English" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		unitExpression			::=	unitTerm .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		unitTerm			::=	unitFactor {midPrecedenceOperator unitFactor} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		unitFactor			::=	[unaryMinus] (unit [highPrecedenceOperator numericConst] | "(" unitExpression ")") .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		unit				::=	identifier .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		sensorPropertyList		::=	sensorProperty {"," sensorProperty} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		sensorProperty			::=	rangeStatement | uncertaintyStatement | erasureValueStatement | accuracyStatement | precisionStatement | sensorInterfaceStatement .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		sensorInterfaceStatement	::=	"interface" identifier "==" sensorInterfaceType parameterTuple ["{" sensorInterfaceCommandList "}"] .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		sensorInterfaceType		::=	"i2c" | "spi" | "analog" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		sensorInterfaceCommandList	::=	sensorInterfaceCommand {";" sensorInterfaceCommand} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		sensorInterfaceCommand		::=	readRegisterCommand | writeRegisterCommand | delayCommand | ssaArithmeticCommand .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		readRegisterCommand		::=	ssaIdentifier ":=" "read" numericConst .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		writeRegisterCommand		::=	"write" numericConst numericConst .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		delayCommand			::=	"delay" numericConst .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		ssaIdentifier			=	identifier .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		ssaArithmeticCommand		::=	identifier "=" expression .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		rangeStatement			::=	"range" identifier "==" "[" numericConst [unitExpression] "," numericConst [unitExpression] "]" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		uncertaintyStatement		::=	"uncertainty" identifier "==" expression [unitExpression] .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		erasureValueStatement		::=	"erasuretoken" identifier "==" numericConst [unitExpression] .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		accuracyStatement		::=	"accuracy" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		precisionStatement		::=	"precision" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		numericConstTupleList		::=	"{" numericConstTuple {"," numericConstTuple} "}" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		numericConstTuple		::=	"(" numericConst [unitExpression] ".." numericConst ")" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		expression			::=	term {lowPrecedenceBinaryOp term} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		term				::=	[unaryOp] factor ["++" | "--"] {highPrecedenceBinaryOp factor} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		factor				::=	numericConst | "(" expression ")" | distributionFactor .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		distributionFactor		::=	distribution parameterValueList .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		parameterValueList		::=	"(" identifier ":" expression {"," identifier ":" expression} .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		distribution			::=	"Gaussian" | "exponential" | "biexponential" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		highPrecedenceBinaryOp		::=	"*" | "/" | "%" | "**" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		lowPrecedenceBinaryOp		::=	"+" | "-" | ">>" | "<<" | "|" .
production kNewtonIrNodeType_P:				firstset = {
									}

--//		unaryOp				::=	"-"  | "+" .
production kNewtonIrNodeType_P:				firstset = {
									}






--//
--//
--//
--//
--//
--//	FOLLOW()s
--//
--//
--//
--//		numericConst			::=	integerConst | realConst .
production kNewtonIrNodeType_P:				followset = {
									}

--//		newtonDescription		::=	ruleList .
production kNewtonIrNodeType_P:					followset = {
									}

--//		ruleList			::=	{rule} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		rule				::=	constantDefinition | invariantDefinition | baseSignalDefinition | sensorDefinition .
production kNewtonIrNodeType_P:				followset = {
									}

--//		constantDefinition		::=	identifier ":" "constant" "=" numericConst [unitExpression] ";" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		invariantDefinition		::=	identifier ":" "invariant" parameterTuple  "=" "{" constraintList "}" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		baseSignalDefinition		::=	identifier ":" "signal" [subdimensionTuple] "=" "{" [nameStatement] symbolStatement derivationStatement "}" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		sensorDefinition		::=	identifier ":" "sensor" parameterTuple = "{" sensorPropertyList "}" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		nameStatement			::=	"name" "=" stringConst languageSetting ";" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		symbolStatement			::=	"symbol" "=" identifier ";" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		derivationStatement		::=	"derivation" "=" ("none" | quantityExpression) ";" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		subdimensionTuple		::=	"(" identifier ":" numericConst "to" numericConst ")" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		parameterTuple			::=	"(" parameter {"," parameter} ")" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		parameter			::=	identifier ":" identifier .
production kNewtonIrNodeType_P:				followset = {
									}

--//		constraintList			::=	constraint {"," constraint} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		constraint			::=	quantityExpression comparisonOperator quantityExpression .
production kNewtonIrNodeType_P:				followset = {
									}

--//		quantityExpression		::=	quantityTerm {lowPrecedenceOperator quantityTerm} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		quantityTerm			::=	[unaryMinus] quantityFactor {midPrecedenceOperator quantityFactor} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		quantityFactor			::=	quantity								|
--//							quantity [highPrecedenceOperator quantityExpression]			|
--//								timeOperator {timeOperator} quantityExpression			|
--//								"(" quantityExpression ")" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		quantity			::=	numericConst | (identifier {"@" numericConst}) .
production kNewtonIrNodeType_P:				followset = {
									}

--//		lowPrecedenceOperator		::=	"+" | "-" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		midPrecedenceOperator		::=	"*" | "/" | vectorOp .
production kNewtonIrNodeType_P:				followset = {
									}

--//		highPrecedenceOperator		::=	"**" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		vectorOp			::=	"dot" | "cross" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		timeOperator			::=	"derivative" | "integral" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		comparisonOperator		::=	"o<" | "~" | "<" | "<=" | ">" | ">=" | "==" | "<->" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		unaryMinus			::=	"-" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		languageSetting			::=	"English" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		unitExpression			::=	unitTerm .
production kNewtonIrNodeType_P:				followset = {
									}

--//		unitTerm			::=	unitFactor {midPrecedenceOperator unitFactor} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		unitFactor			::=	[unaryMinus] (unit [highPrecedenceOperator numericConst] | "(" unitExpression ")") .
production kNewtonIrNodeType_P:				followset = {
									}

--//		unit				::=	identifier .
production kNewtonIrNodeType_P:				followset = {
									}

--//		sensorPropertyList		::=	sensorProperty {"," sensorProperty} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		sensorProperty			::=	rangeStatement | uncertaintyStatement | erasureValueStatement | accuracyStatement | precisionStatement | sensorInterfaceStatement .
production kNewtonIrNodeType_P:				followset = {
									}

--//		sensorInterfaceStatement	::=	"interface" identifier "==" sensorInterfaceType parameterTuple ["{" sensorInterfaceCommandList "}"] .
production kNewtonIrNodeType_P:				followset = {
									}

--//		sensorInterfaceType		::=	"i2c" | "spi" | "analog" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		sensorInterfaceCommandList	::=	sensorInterfaceCommand {";" sensorInterfaceCommand} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		sensorInterfaceCommand		::=	readRegisterCommand | writeRegisterCommand | delayCommand | ssaArithmeticCommand .
production kNewtonIrNodeType_P:				followset = {
									}

--//		readRegisterCommand		::=	ssaIdentifier ":=" "read" numericConst .
production kNewtonIrNodeType_P:				followset = {
									}

--//		writeRegisterCommand		::=	"write" numericConst numericConst .
production kNewtonIrNodeType_P:				followset = {
									}

--//		delayCommand			::=	"delay" numericConst .
production kNewtonIrNodeType_P:				followset = {
									}

--//		ssaIdentifier			=	identifier .
production kNewtonIrNodeType_P:				followset = {
									}

--//		ssaArithmeticCommand		::=	identifier "=" expression .
production kNewtonIrNodeType_P:				followset = {
									}

--//		rangeStatement			::=	"range" identifier "==" "[" numericConst [unitExpression] "," numericConst [unitExpression] "]" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		uncertaintyStatement		::=	"uncertainty" identifier "==" expression [unitExpression] .
production kNewtonIrNodeType_P:				followset = {
									}

--//		erasureValueStatement		::=	"erasuretoken" identifier "==" numericConst [unitExpression] .
production kNewtonIrNodeType_P:				followset = {
									}

--//		accuracyStatement		::=	"accuracy" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_P:				followset = {
									}

--//		precisionStatement		::=	"precision" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_P:				followset = {
									}

--//		numericConstTupleList		::=	"{" numericConstTuple {"," numericConstTuple} "}" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		numericConstTuple		::=	"(" numericConst [unitExpression] ".." numericConst ")" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		expression			::=	term {lowPrecedenceBinaryOp term} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		term				::=	[unaryOp] factor ["++" | "--"] {highPrecedenceBinaryOp factor} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		factor				::=	numericConst | "(" expression ")" | distributionFactor .
production kNewtonIrNodeType_P:				followset = {
									}

--//		distributionFactor		::=	distribution parameterValueList .
production kNewtonIrNodeType_P:				followset = {
									}

--//		parameterValueList		::=	"(" identifier ":" expression {"," identifier ":" expression} .
production kNewtonIrNodeType_P:				followset = {
									}

--//		distribution			::=	"Gaussian" | "exponential" | "biexponential" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		highPrecedenceBinaryOp		::=	"*" | "/" | "%" | "**" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		lowPrecedenceBinaryOp		::=	"+" | "-" | ">>" | "<<" | "|" .
production kNewtonIrNodeType_P:				followset = {
									}

--//		unaryOp				::=	"-"  | "+" .
production kNewtonIrNodeType_P:				followset = {
									}






token	kNewtonIrNodeType_TEnglish:			followset = {
									}
token	kNewtonIrNodeType_Taccuracy:			followset = {
									}
token	kNewtonIrNodeType_Tanalog:			followset = {
									}
token	kNewtonIrNodeType_TatSign:			followset = {
									}
token	kNewtonIrNodeType_Tbiexponential:		followset = {
									}
token	kNewtonIrNodeType_Tcolon:			followset = {
									}
token	kNewtonIrNodeType_Tcomma:			followset = {
									}
token	kNewtonIrNodeType_Tconstant:			followset = {
									}
token	kNewtonIrNodeType_Tcross:			followset = {
									}
token	kNewtonIrNodeType_Tdelay:			followset = {
									}
token	kNewtonIrNodeType_Tderivation:			followset = {
									}
token	kNewtonIrNodeType_Tderivative:			followset = {
									}
token	kNewtonIrNodeType_Tdiv:				followset = {
									}
token	kNewtonIrNodeType_Tdot:				followset = {
									}
token	kNewtonIrNodeType_Tequals:			followset = {
									}
token	kNewtonIrNodeType_Tequivalent:			followset = {
									}
token	kNewtonIrNodeType_Terasuretoken:		followset = {
									}
token	kNewtonIrNodeType_Texponent:			followset = {
									}
token	kNewtonIrNodeType_Texponential:			followset = {
									}
token	kNewtonIrNodeType_Tgaussian:			followset = {
									}
token	kNewtonIrNodeType_Tge:				followset = {
									}
token	kNewtonIrNodeType_Tgt:				followset = {
									}
token	kNewtonIrNodeType_Ti2c:				followset = {
									}
token	kNewtonIrNodeType_Tintegral:			followset = {
									}
token	kNewtonIrNodeType_Tinterface:			followset = {
									}
token	kNewtonIrNodeType_Tinvariant:			followset = {
									}
token	kNewtonIrNodeType_Tle:				followset = {
									}
token	kNewtonIrNodeType_TleftBrace:			followset = {
									}
token	kNewtonIrNodeType_TleftParen:			followset = {
									}
token	kNewtonIrNodeType_TleftShift:			followset = {
									}
token	kNewtonIrNodeType_Tlt:				followset = {
									}
token	kNewtonIrNodeType_Tminus:			followset = {
									}
token	kNewtonIrNodeType_Tmul:				followset = {
									}
token	kNewtonIrNodeType_Tname:			followset = {
									}
token	kNewtonIrNodeType_Tnil:				followset = {
									}
token	kNewtonIrNodeType_Tnone:			followset = {
									}
token	kNewtonIrNodeType_Tplus:			followset = {
									}
token	kNewtonIrNodeType_Tprecision:			followset = {
									}
token	kNewtonIrNodeType_Tproportionality:		followset = {
									}
token	kNewtonIrNodeType_Trange:			followset = {
									}
token	kNewtonIrNodeType_Tread:			followset = {
									}
token	kNewtonIrNodeType_Trelated:			followset = {
									}
token	kNewtonIrNodeType_TrightBrace:			followset = {
									}
token	kNewtonIrNodeType_TrightParen:			followset = {
									}
token	kNewtonIrNodeType_TrightShift:			followset = {
									}
token	kNewtonIrNodeType_Tsemicolon:			followset = {
									}
token	kNewtonIrNodeType_Tsensor:			followset = {
									}
token	kNewtonIrNodeType_Tsignal:			followset = {
									}
token	kNewtonIrNodeType_Tsignal:			followset = {
									}
token	kNewtonIrNodeType_Tspi:				followset = {
									}
token	kNewtonIrNodeType_Tsymbol:			followset = {
									}
token	kNewtonIrNodeType_Tto:				followset = {
									}
token	kNewtonIrNodeType_Tuncertainty:			followset = {
									}
token	kNewtonIrNodeType_Twrite:			followset = {
									}



token	kNewtonIrNodeType_TintegerConst:		followset = {
									}
token	kNewtonIrNodeType_TrealConst:			followset = {
									}
token	kNewtonIrNodeType_TstringConst:			followset = {
									}
token	kNewtonIrNodeType_Tidentifier:			followset = {
									}
