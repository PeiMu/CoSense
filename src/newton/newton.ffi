--//
--//
--//
--//
--//	Wirth FFI description for Noisy. This is a replacement for the old Newton FFI
--//	(see the comment at the bottom of issue #20 and #317)
--//
--//
--//
--//



--//
--//
--//
--//
--//	FIRST()s
--//
--//
--//
--//

--//		numericConst			::=	integerConst | realConst .
production kNewtonIrNodeType_PnumericConst:		firstset = {
									firstset(kNewtonIrNodeType_TintegerConst),
									firstset(kNewtonIrNodeType_TrealConst),
								}

--//		newtonDescription		::=	ruleList .
production kNewtonIrNodeType_PnewtonDescription:	firstset = {
									firstset(kNewtonIrNodeType_PruleList),
								}

--//		ruleList			::=	{rule} .
production kNewtonIrNodeType_PruleList:			firstset = {
									firstset(kNewtonIrNodeType_Prule),
								}

--//		rule				::=	constantDefinition | invariantDefinition | baseSignalDefinition | sensorDefinition .
production kNewtonIrNodeType_Prule:			firstset = {
									firstset(kNewtonIrNodeType_PconstantDefinition),
									firstset(kNewtonIrNodeType_PinvariantDefinition),
									firstset(kNewtonIrNodeType_PbaseSignalDefinition),
									firstset(kNewtonIrNodeType_PsensorDefinition),
								}

--//		constantDefinition		::=	identifier ":" "constant" "=" numericFactor [unitFactor] ";" .
production kNewtonIrNodeType_PconstantDefinition:	firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		invariantDefinition		::=	identifier ":" "invariant" parameterTuple  "=" "{" [constraintList] "}" .
production kNewtonIrNodeType_PinvariantDefinition:	firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		baseSignalDefinition		::=	identifier ":" "signal" [subdimensionTuple] "=" "{" [nameStatement] [signalUncertaintyStatement] [sensorStatement] symbolStatement derivationStatement "}" .
production kNewtonIrNodeType_PbaseSignalDefinition:	firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		sensorDefinition		::=	identifier ":" "sensor" parameterTuple = "{" sensorPropertyList "}" .
production kNewtonIrNodeType_PsensorDefinition:		firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		nameStatement			::=	"name" "=" stringConst languageSetting ";" .
production kNewtonIrNodeType_PnameStatement:		firstset = {
									kNewtonIrNodeType_Tname,
								}

--//		signalUncertaintyStatement	::= "uncertainty" "=" distribution [parameterTuple] ";" .
production kNewtonIrNodeType_PsignalUncertaintyStatement:		firstset = {
									kNewtonIrNodeType_Tuncertainty,
								}

--//		sensorStatement			::=	"sensor" "=" identifier ";" .
production kNewtonIrNodeType_PsensorStatement:		firstset = {
									kNewtonIrNodeType_Tsensor,
								}

--//		symbolStatement			::=	"symbol" "=" identifier ";" .
production kNewtonIrNodeType_PsymbolStatement:		firstset = {
									kNewtonIrNodeType_Tsymbol,
								}

--//		derivationStatement		::=	"derivation" "=" ("none" | "dimensionless" | quantityExpression) ";" .
production kNewtonIrNodeType_PderivationStatement:	firstset = {
									kNewtonIrNodeType_Tderivation,
								}

--//		subdimensionTuple		::=	"(" identifier ":" numericExpression "to" numericExpression ")" .
production kNewtonIrNodeType_PsubdimensionTuple:	firstset = {
									kNewtonIrNodeType_TleftParen,
								}

--//		parameterTuple			::=	"(" parameter {"," parameter} ")" .
production kNewtonIrNodeType_PparameterTuple:		firstset = {
									kNewtonIrNodeType_TleftParen,
								}

--//		parameter			::=	identifier ":" (identifier | numericExpression) {"@" integerConst} .
production kNewtonIrNodeType_Pparameter:		firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		constraintList			::=	constraint {"," constraint} .
production kNewtonIrNodeType_PconstraintList:		firstset = {
									firstset(kNewtonIrNodeType_Pconstraint),
								}

--//		constraint			::=	quantityExpression comparisonOperator quantityExpression | identifier parameterTuple | piecewiseConstraint.
production kNewtonIrNodeType_Pconstraint:		firstset = {
									firstset(kNewtonIrNodeType_PquantityExpression),
									firstset(kNewtonIrNodeType_PpiecewiseConstraint),
								}
--//		callParameterTuple		::=	"(" identifier {"," identifier} ")" .
production kNewtonIrNodeType_PcallParameterTuple:	firstset = {
									kNewtonIrNodeType_TleftParen,
								}

--//		piecewiseConstraint		::=	"piecewise" "{" caseList "}" .
production kNewtonIrNodeType_PpiecewiseConstraint:	firstset = {
									kNewtonIrNodeType_Tpiecewise,
								}

--//		caseStatementList		::=	caseStatement {"," caseStatement} .
production kNewtonIrNodeType_PcaseStatementList:	firstset = {
									firstset(kNewtonIrNodeType_PcaseStatement),
								}

--//		caseStatement			::=	("case" constraint | "otherwise" )"->" "{" constraintList "}" .
production kNewtonIrNodeType_PcaseStatement:		firstset = {
								kNewtonIrNodeType_Tcase,
								kNewtonIrNodeType_Totherwise,
							}

--//		quantityExpression		::=	quantityTerm {lowPrecedenceOperator quantityTerm} .
production kNewtonIrNodeType_PquantityExpression:	firstset = {
									firstset(kNewtonIrNodeType_PquantityTerm),
								}

--//		quantityTerm			::=	[unaryOp] quantityFactor {highPrecedenceQuantityOperator quantityFactor} .
production kNewtonIrNodeType_PquantityTerm:		firstset = {
									firstset(kNewtonIrNodeType_PunaryOp),
									firstset(kNewtonIrNodeType_PquantityFactor),
								}

--//		quantityFactor			::=	quantity [exponentiationOperator numericFactor]						|
--//								functionalOperator {functionalOperator} quantityFactor quantityFactor		|
--//								distribution "(" quantityExpression {"," quantityExpression} ")" 		|
--//								transcendental "(" quantityExpression ")"			|
--//								"(" quantityExpression ")" [exponentiationOperator numericFactor]			|
--//								"{" quantityExpression {"," quantityExpression} "}" .
production kNewtonIrNodeType_PquantityFactor:		firstset = {
									kNewtonIrNodeType_TleftParen,
									kNewtonIrNodeType_TleftBrace,
									firstset(kNewtonIrNodeType_PfunctionalOperator),
									firstset(kNewtonIrNodeType_Pdistribution),
									firstset(kNewtonIrNodeType_Ptranscendental),
									firstset(kNewtonIrNodeType_Pquantity),
								}

--//		quantity			::=	numericConst | (identifier ["@" numericFactor]) .
production kNewtonIrNodeType_Pquantity:			firstset = {
									kNewtonIrNodeType_Tidentifier,
									firstset(kNewtonIrNodeType_PnumericConst),
								}

--//		lowPrecedenceOperator		::=	"+" | "-" .
production kNewtonIrNodeType_PlowPrecedenceOperator:	firstset = {
									kNewtonIrNodeType_Tplus,
									kNewtonIrNodeType_Tminus,
								}

--//		highPrecedenceQuantityOperator		::=	highPrecedenceOperator | vectorOp | "><" .
production kNewtonIrNodeType_PhighPrecedenceQuantityOperator:	firstset = {
									firstset(kNewtonIrNodeType_PhighPrecedenceOperator),
									firstset(kNewtonIrNodeType_PvectorOp),
									kNewtonIrNodeType_Tmutualinf,
								}

--//		highPrecedenceOperator		::=	"*" | "/" .
production kNewtonIrNodeType_PhighPrecedenceOperator:	firstset = {
									kNewtonIrNodeType_Tmul,
									kNewtonIrNodeType_Tdiv,
								}


--//		exponentiationOperator		::=	"**" .
production kNewtonIrNodeType_PexponentiationOperator:	firstset = {
									kNewtonIrNodeType_Texponentiation,
								}

--//		vectorOp			::=	"dot" | "cross" .
production kNewtonIrNodeType_PvectorOp:			firstset = {
									kNewtonIrNodeType_Tdot,
									kNewtonIrNodeType_Tcross,
								}

--//		functionalOperator		::=	"derivative" | "integral" .
production kNewtonIrNodeType_PfunctionalOperator:		firstset = {
									kNewtonIrNodeType_Tderivative,
									kNewtonIrNodeType_Tintegral,
								}

--//		comparisonOperator		::=	"o<" | "~" | "<" | "<=" | ">" | ">=" | "==" | "<->" .
production kNewtonIrNodeType_PcomparisonOperator:	firstset = {
									kNewtonIrNodeType_TdimensionallyAgnosticProportional,
									kNewtonIrNodeType_TdimensionallyMatchingProportional,
									kNewtonIrNodeType_Tlt,
									kNewtonIrNodeType_Tle,
									kNewtonIrNodeType_Tgt,
									kNewtonIrNodeType_Tge,
									kNewtonIrNodeType_Tequals,
									kNewtonIrNodeType_Trelated,
								}

--//		languageSetting			::=	"English" .
production kNewtonIrNodeType_PlanguageSetting:		firstset = {
									kNewtonIrNodeType_TEnglish,
								}

--//		unitExpression			::=	unitTerm .
production kNewtonIrNodeType_PunitExpression:		firstset = {
									firstset(kNewtonIrNodeType_PunitTerm),
								}

--//		unitTerm			::=	unitFactor {highPrecedenceQuantityOperator unitFactor} .
production kNewtonIrNodeType_PunitTerm:			firstset = {
									firstset(kNewtonIrNodeType_PunitFactor),
								}

--//		unitFactor			::=	(unit [exponentiationOperator numericFactor]) | "(" unitExpression ")" .
production kNewtonIrNodeType_PunitFactor:		firstset = {
									firstset(kNewtonIrNodeType_Punit),
									kNewtonIrNodeType_TleftParen,
								}

--//		unit				::=	identifier .
production kNewtonIrNodeType_Punit:			firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		numericExpression			::=	numericTerm {lowPrecedenceOperator numericTerm} .
production kNewtonIrNodeType_PnumericExpression:	firstset = {
									firstset(kNewtonIrNodeType_PnumericTerm),
								}

--//		numericTerm			::=	numericFactor {highPrecedenceOperator numericFactor} .
production kNewtonIrNodeType_PnumericTerm:		firstset = {
									firstset(kNewtonIrNodeType_PnumericFactor),
								}

--//		numericFactor			::=	numericConst [exponentiationOperator numericConst] | "(" numericExpression ")" .
production kNewtonIrNodeType_PnumericFactor:		firstset = {
									firstset(kNewtonIrNodeType_PnumericConst),
									kNewtonIrNodeType_TleftParen,
								}

--//		sensorPropertyList		::=	sensorProperty {"," sensorProperty} .
production kNewtonIrNodeType_PsensorPropertyList:	firstset = {
									firstset(kNewtonIrNodeType_PsensorProperty),
								}

--//		sensorProperty			::=	rangeStatement | uncertaintyStatement | erasureValueStatement | accuracyStatement | precisionStatement | sensorInterfaceStatement .
production kNewtonIrNodeType_PsensorProperty:		firstset = {
									firstset(kNewtonIrNodeType_PrangeStatement),
									firstset(kNewtonIrNodeType_PuncertaintyStatement),
									firstset(kNewtonIrNodeType_PerasureValueStatement),
									firstset(kNewtonIrNodeType_PaccuracyStatement),
									firstset(kNewtonIrNodeType_PprecisionStatement),
									firstset(kNewtonIrNodeType_PsensorInterfaceStatement),
								}

--//		sensorInterfaceStatement	::=	"interface" identifier ["@" numericFactor "bits"] "==" sensorInterfaceType [parameterTuple ["{" sensorInterfaceCommandList "}"]] .
production kNewtonIrNodeType_PsensorInterfaceStatement:	firstset = {
									kNewtonIrNodeType_Tinterface,
								}

--//		sensorInterfaceType		::=	"i2c" | "spi" | "analog" .
production kNewtonIrNodeType_PsensorInterfaceType:	firstset = {
									kNewtonIrNodeType_Tspi,
									kNewtonIrNodeType_Ti2c,
									kNewtonIrNodeType_Tanalog,
								}

--//		sensorInterfaceCommandList	::=	sensorInterfaceCommand ";" {sensorInterfaceCommand ";"} .
production kNewtonIrNodeType_PsensorInterfaceCommandList:	firstset = {
									firstset(kNewtonIrNodeType_PsensorInterfaceCommand),
								}

--//		sensorInterfaceCommand		::=	readRegisterCommand | writeRegisterCommand | delayCommand | arithmeticCommand .
production kNewtonIrNodeType_PsensorInterfaceCommand:	firstset = {
									firstset(kNewtonIrNodeType_PreadRegisterCommand),
									firstset(kNewtonIrNodeType_PwriteRegisterCommand),
									firstset(kNewtonIrNodeType_PdelayCommand),
									firstset(kNewtonIrNodeType_ParithmeticCommand),
								}

--//		readRegisterCommand		::=	identifier "=" "read" ["[" numericExpression "]" ","] numericExpression .
production kNewtonIrNodeType_PreadRegisterCommand:	firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		writeRegisterCommand		::=	"write" numericExpression "," numericExpression .
production kNewtonIrNodeType_PwriteRegisterCommand:	firstset = {
									kNewtonIrNodeType_Twrite,
								}

--//		delayCommand			::=	"delay" numericExpression .
production kNewtonIrNodeType_PdelayCommand:		firstset = {
									kNewtonIrNodeType_Tdelay,
								}

--//		arithmeticCommand		::=	identifier "=" expression .
production kNewtonIrNodeType_ParithmeticCommand:	firstset = {
									kNewtonIrNodeType_Tidentifier,
								}

--//		rangeStatement			::=	"range" identifier "==" "[" numericFactor [unitFactor] "," numericFactor [unitFactor] "]" .
production kNewtonIrNodeType_PrangeStatement:		firstset = {
									kNewtonIrNodeType_Trange,
								}

--//		uncertaintyStatement		::=	"uncertainty" identifier "==" factor [unitFactor] .
production kNewtonIrNodeType_PuncertaintyStatement:	firstset = {
									kNewtonIrNodeType_Tuncertainty,
								}

--//		erasureValueStatement		::=	"erasuretoken" identifier "==" numericFactor [unitFactor] .
production kNewtonIrNodeType_PerasureValueStatement:	firstset = {
									kNewtonIrNodeType_TerasureToken,
								}

--//		accuracyStatement		::=	"accuracy" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_PaccuracyStatement:	firstset = {
									kNewtonIrNodeType_Taccuracy,
								}

--//		precisionStatement		::=	"precision" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_PprecisionStatement:	firstset = {
									kNewtonIrNodeType_Tprecision,
								}

--//		numericConstTupleList		::=	"{" numericConstTuple {"," numericConstTuple} "}" .
production kNewtonIrNodeType_PnumericConstTupleList:	firstset = {
									kNewtonIrNodeType_TleftBrace,
								}

--//		numericConstTuple		::=	"(" numericFactor [unitFactor] "," numericFactor ")" .
production kNewtonIrNodeType_PnumericConstTuple:	firstset = {
									kNewtonIrNodeType_TleftParen,
								}

--//		expression			::=	term {lowPrecedenceBinaryOp term} .
production kNewtonIrNodeType_Pexpression:		firstset = {
									firstset(kNewtonIrNodeType_Pterm),
								}

--//		term				::=	[unaryOp] factor ["++" | "--"] {highPrecedenceBinaryOp factor} .
production kNewtonIrNodeType_Pterm:			firstset = {
									firstset(kNewtonIrNodeType_PunaryOp),
									firstset(kNewtonIrNodeType_Pfactor),
								}

--//		factor				::=	numericConst | "(" expression ")" | distributionFactor | identifier ["[" numericExpression "]"] .
production kNewtonIrNodeType_Pfactor:			firstset = {
									firstset(kNewtonIrNodeType_PnumericConst),
									kNewtonIrNodeType_TleftParen,
									firstset(kNewtonIrNodeType_PdistributionFactor),
									kNewtonIrNodeType_Tidentifier,
								}

--//		distributionFactor		::=	distribution parameterValueList .
production kNewtonIrNodeType_PdistributionFactor:	firstset = {
									firstset(kNewtonIrNodeType_Pdistribution),
								}

--//		parameterValueList		::=	"(" identifier ":" expression {"," identifier ":" expression} ")" .
production kNewtonIrNodeType_PparameterValueList:	firstset = {
									kNewtonIrNodeType_TleftParen,
								}

--//		distribution			::=	 "Gaussian" | "Laplacian" | "StudentT" | "Bernoulli" | "Binomial" 
--//							| "Poisson" | "NegativeBinomial" | "BetaBinomial" | "Exponential"
--//							| "Gamma" | "Multinomial" | "Beta" | "LogitNormal" | "Dirichlet"
--//							| "Cauchy" | "LogNormal" | "Pareto" | "BetaPrime" | "StudentZ" 
--//							| "Weibull" | "Erlang" | "Maxwell" | "FermiDirac" | "FisherZ" 
--//							| "LogSeries" | "Gumbel" | "Rayleigh" | "Gibrat" | "PearsonIII"
--//							| "ExtremeValue" | "F" | "Xi" | "XiSquared" .
production kNewtonIrNodeType_Pdistribution:		firstset = {
									kNewtonIrNodeType_TGaussian,
									kNewtonIrNodeType_TLaplacian,
									kNewtonIrNodeType_TStudentT,
									kNewtonIrNodeType_TBernoulli,
									kNewtonIrNodeType_TBinomial,
									kNewtonIrNodeType_TPoisson,
									kNewtonIrNodeType_TNegativeBinomial,
									kNewtonIrNodeType_TBetaBinomial,
									kNewtonIrNodeType_TExponential,
									kNewtonIrNodeType_TGamma,
									kNewtonIrNodeType_TMultinomial,
									kNewtonIrNodeType_TBeta,
									kNewtonIrNodeType_TLogitNormal,
									kNewtonIrNodeType_TDirichlet,
									kNewtonIrNodeType_TCauchy,
									kNewtonIrNodeType_TLogNormal,
									kNewtonIrNodeType_TPareto,
									kNewtonIrNodeType_TBetaPrime,
									kNewtonIrNodeType_TStudentZ,
									kNewtonIrNodeType_TWeibull,
									kNewtonIrNodeType_TErlang,
									kNewtonIrNodeType_TMaxwell,
									kNewtonIrNodeType_TFermiDirac,
									kNewtonIrNodeType_TFisherZ,
									kNewtonIrNodeType_TLogSeries,
									kNewtonIrNodeType_TGumbel,
									kNewtonIrNodeType_TRayleigh,
									kNewtonIrNodeType_TGibrat,
									kNewtonIrNodeType_TPearsonIII,
									kNewtonIrNodeType_TExtremeValue,
									kNewtonIrNodeType_TF,
									kNewtonIrNodeType_TXi,
									kNewtonIrNodeType_TXiSquared,
									kNewtonIrNodeType_TUnconstrained,									
								}

--//		transcendental			::= "sin" | "cos" | "tan"
--//								| "arcsin" | "arccos" | "arctan"
--//								| "sinh" | "cosh" | "tanh"
--//								| "exp" | "sqrt"
--//								| "ln" | "log10" | "log2" .
production kNewtonIrNodeType_Ptranscendental:	firstset = {
									kNewtonIrNodeType_Tsin,
									kNewtonIrNodeType_Tcos,
									kNewtonIrNodeType_Ttan,
									kNewtonIrNodeType_Tcotan,
									kNewtonIrNodeType_Tsec,
									kNewtonIrNodeType_Tcosec,
									kNewtonIrNodeType_Tarcsin,
									kNewtonIrNodeType_Tarccos,
									kNewtonIrNodeType_Tarctan,
									kNewtonIrNodeType_Tarccotan,
									kNewtonIrNodeType_Tarcsec,
									kNewtonIrNodeType_Tarccosec,
									kNewtonIrNodeType_Tsinh,
									kNewtonIrNodeType_Tcosh,
									kNewtonIrNodeType_Ttanh,
									kNewtonIrNodeType_Tcotanh,
									kNewtonIrNodeType_Tsech,
									kNewtonIrNodeType_Tcosech,
									kNewtonIrNodeType_Tarcsinh,
									kNewtonIrNodeType_Tarccosh,
									kNewtonIrNodeType_Tarctanh,
									kNewtonIrNodeType_Tarccotanh,
									kNewtonIrNodeType_Tarcsech,
									kNewtonIrNodeType_Tarccosech,
									kNewtonIrNodeType_Texp,
									kNewtonIrNodeType_Tsqrt,
									kNewtonIrNodeType_Tln,
									kNewtonIrNodeType_Tlog10,
									kNewtonIrNodeType_Tlog2
								}

--//		highPrecedenceBinaryOp		::=	"*" | "/" | "%" | "**" .
production kNewtonIrNodeType_PhighPrecedenceBinaryOp:	firstset = {
									kNewtonIrNodeType_Tmul,
									kNewtonIrNodeType_Tdiv,
									kNewtonIrNodeType_Tpercent,
									kNewtonIrNodeType_Texponentiation,
									}

--//		lowPrecedenceBinaryOp		::=	"+" | "-" | ">>" | "<<" | "|" .
production kNewtonIrNodeType_PlowPrecedenceBinaryOp:	firstset = {
									kNewtonIrNodeType_Tplus,
									kNewtonIrNodeType_Tminus,
									kNewtonIrNodeType_TrightShift,
									kNewtonIrNodeType_TleftShift,
									kNewtonIrNodeType_TbitwiseOr,
									}

--//		unaryOp				::=	"-"  | "+" .
production kNewtonIrNodeType_PunaryOp:			firstset = {
									kNewtonIrNodeType_Tplus,
									kNewtonIrNodeType_Tminus,
								}






--//
--//
--//
--//
--//	FOLLOW()s
--//
--//
--//
--//

--//		numericConst			::=	integerConst | realConst .
production kNewtonIrNodeType_PnumericConst:		followset = {
									firstset(kNewtonIrNodeType_PexponentiationOperator),
									followset(kNewtonIrNodeType_PnumericFactor),
									followset(kNewtonIrNodeType_Pfactor),
								}

--//		newtonDescription		::=	ruleList .
production kNewtonIrNodeType_PnewtonDescription:	followset = {
									kNewtonIrNodeType_Zeof,
								}

--//		ruleList			::=	{rule} .
production kNewtonIrNodeType_PruleList:			followset = {
									followset(kNewtonIrNodeType_PnewtonDescription),
								}

--//		rule				::=	constantDefinition | invariantDefinition | baseSignalDefinition | sensorDefinition .
production kNewtonIrNodeType_Prule:			followset = {
									firstset(kNewtonIrNodeType_Prule),
								}

--//		constantDefinition		::=	identifier ":" "constant" "=" numericFactor [unitFactor] ";" .
production kNewtonIrNodeType_PconstantDefinition:	followset = {
									followset(kNewtonIrNodeType_Prule),
								}

--//		invariantDefinition		::=	identifier ":" "invariant" parameterTuple  "=" "{" [constraintList] "}" .
production kNewtonIrNodeType_PinvariantDefinition:	followset = {
									followset(kNewtonIrNodeType_Prule),
								}

--//		baseSignalDefinition		::=	identifier ":" "signal" [subdimensionTuple] "=" "{" [nameStatement] [signalUncertaintyStatement] [sensorStatement] symbolStatement derivationStatement "}" .
production kNewtonIrNodeType_PbaseSignalDefinition:	followset = {
									followset(kNewtonIrNodeType_Prule),
								}

--//		sensorDefinition		::=	identifier ":" "sensor" parameterTuple = "{" sensorPropertyList "}" .
production kNewtonIrNodeType_PsensorDefinition:		followset = {
									followset(kNewtonIrNodeType_Prule),
								}

--//		nameStatement			::=	"name" "=" stringConst languageSetting ";" .
production kNewtonIrNodeType_PnameStatement:		followset = {
									firstset(kNewtonIrNodeType_PsignalUncertaintyStatement),
									firstset(kNewtonIrNodeType_PsensorStatement),
									firstset(kNewtonIrNodeType_PsymbolStatement),
								}

--//		signalUncertaintyStatement	::= "uncertainty" "=" distribution [parameterTuple] ";" .
production kNewtonIrNodeType_PsignalUncertaintyStatement:		followset = {
									firstset(kNewtonIrNodeType_PsensorStatement),
									firstset(kNewtonIrNodeType_PsymbolStatement),
								}

--//		sensorStatement			::=	"sensor" "=" identifier ";" .
production kNewtonIrNodeType_PsensorStatement:		followset = {
									firstset(kNewtonIrNodeType_PsymbolStatement),
								}

--//		symbolStatement			::=	"symbol" "=" identifier ";" .
production kNewtonIrNodeType_PsymbolStatement:		followset = {
									firstset(kNewtonIrNodeType_PderivationStatement),
								}

--//		derivationStatement		::=	"derivation" "=" ("none" | "dimensionless" | quantityExpression) ";" .
production kNewtonIrNodeType_PderivationStatement:	followset = {
									kNewtonIrNodeType_TrightBrace,
								}

--//		subdimensionTuple		::=	"(" identifier ":" numericExpression "to" numericExpression ")" .
production kNewtonIrNodeType_PsubdimensionTuple:	followset = {
									kNewtonIrNodeType_Tequals,
								}

--//		parameterTuple			::=	"(" parameter {"," parameter} ")" .
production kNewtonIrNodeType_PparameterTuple:		followset = {
									kNewtonIrNodeType_Tequals,
									followset(kNewtonIrNodeType_Pconstraint),
									kNewtonIrNodeType_TleftBrace,
									followset(kNewtonIrNodeType_PsensorInterfaceStatement),
								}

--//		parameter			::=	identifier ":" (identifier | numericExpression) {"@" integerConst} .
production kNewtonIrNodeType_Pparameter:		followset = {
									kNewtonIrNodeType_Tcomma,
									kNewtonIrNodeType_TrightParen,
								}

--//		constraintList			::=	constraint {"," constraint} .
production kNewtonIrNodeType_PconstraintList:		followset = {
									kNewtonIrNodeType_TrightBrace,
								}

--//		constraint			::=	quantityExpression comparisonOperator quantityExpression | identifier parameterTuple .
production kNewtonIrNodeType_Pconstraint:		followset = {
									kNewtonIrNodeType_Tcomma,
									followset(kNewtonIrNodeType_PconstraintList),
									kNewtonIrNodeType_TrightArrow,
								}

--//		callParameterTuple		::=	"(" identifier {"," identifier} ")" .
production kNewtonIrNodeType_PcallParameterTuple:	followset = {
									followset(kNewtonIrNodeType_Pconstraint),
								}
--//		piecewiseConstraint		::=	"piecewise" "{" caseList "}" .
production kNewtonIrNodeType_PpiecewiseConstraint:	followset = {
									followset(kNewtonIrNodeType_Pconstraint),
								}

--//		caseStatementList		::=	caseStatement {"," caseStatement} .
production kNewtonIrNodeType_PcaseStatementList:	followset = {
									kNewtonIrNodeType_TrightBrace,	
								}

--//		caseStatement			::=	("case" constraint | "otherwise" )"->" "{" constraintList "}" .
production kNewtonIrNodeType_PcaseStatement:		followset = {
									followset(kNewtonIrNodeType_PcaseStatementList),
									kNewtonIrNodeType_Tcomma,
							}

--//		quantityExpression		::=	quantityTerm {lowPrecedenceOperator quantityTerm} .
production kNewtonIrNodeType_PquantityExpression:	followset = {
									kNewtonIrNodeType_Tsemicolon,
									firstset(kNewtonIrNodeType_PcomparisonOperator),
									followset(kNewtonIrNodeType_Pconstraint),
									kNewtonIrNodeType_TrightParen,
									kNewtonIrNodeType_TrightBrace,
								}

--//		quantityTerm			::=	[unaryOp] quantityFactor {highPrecedenceQuantityOperator quantityFactor} .
production kNewtonIrNodeType_PquantityTerm:		followset = {
									firstset(kNewtonIrNodeType_PlowPrecedenceOperator),
									followset(kNewtonIrNodeType_PquantityExpression),
								}

--//		quantityFactor			::=	quantity [exponentiationOperator numericFactor]						|
--//								functionalOperator {functionalOperator} quantityFactor quantityFactor		|
--//								distribution "(" quantityExpression {"," quantityExpression} ")" 		|
--//								"(" quantityExpression ")" [exponentiationOperator numericFactor]		|
--//								"{" quantityExpression {"," quantityExpression} "}" .
production kNewtonIrNodeType_PquantityFactor:		followset = {
									firstset(kNewtonIrNodeType_PhighPrecedenceQuantityOperator),
									followset(kNewtonIrNodeType_PquantityTerm),
								}

--//		quantity			::=	numericConst | (identifier ["@" numericFactor]) .
production kNewtonIrNodeType_Pquantity:			followset = {
									followset(kNewtonIrNodeType_PquantityFactor),
									firstset(kNewtonIrNodeType_PexponentiationOperator),
								}

--//		lowPrecedenceOperator		::=	"+" | "-" .
production kNewtonIrNodeType_PlowPrecedenceOperator:	followset = {
									firstset(kNewtonIrNodeType_PquantityTerm),
								}

--//		highPrecedenceQuantityOperator		::=	highPrecedenceOperator | vectorOp | "><" .
production kNewtonIrNodeType_PhighPrecedenceQuantityOperator:	followset = {
									firstset(kNewtonIrNodeType_PquantityFactor),
									firstset(kNewtonIrNodeType_PunitFactor),
								}

--//		highPrecedenceOperator		::=	"*" | "/" .
production kNewtonIrNodeType_PhighPrecedenceOperator:	followset = {
									firstset(kNewtonIrNodeType_PnumericFactor),
									firstset(kNewtonIrNodeType_PunitFactor),
								}

--//		exponentiationOperator		::=	"**" .
production kNewtonIrNodeType_PexponentiationOperator:	followset = {
									firstset(kNewtonIrNodeType_PnumericFactor),
								}

--//		vectorOp			::=	"dot" | "cross" .
production kNewtonIrNodeType_PvectorOp:			followset = {
									followset(kNewtonIrNodeType_PhighPrecedenceQuantityOperator),
								}

--//		functionalOperator		::=	"derivative" | "integral" .
production kNewtonIrNodeType_PfunctionalOperator:		followset = {
									firstset(kNewtonIrNodeType_PfunctionalOperator),
									firstset(kNewtonIrNodeType_PquantityExpression),
								}

--//		comparisonOperator		::=	"o<" | "~" | "<" | "<=" | ">" | ">=" | "==" | "<->" .
production kNewtonIrNodeType_PcomparisonOperator:	followset = {
									firstset(kNewtonIrNodeType_PquantityExpression),
								}

--//		languageSetting			::=	"English" .
production kNewtonIrNodeType_PlanguageSetting:		followset = {
									kNewtonIrNodeType_Tsemicolon,
								}

--//		unitExpression			::=	unitTerm .
production kNewtonIrNodeType_PunitExpression:		followset = {
									kNewtonIrNodeType_TrightParen,
								}

--//		unitTerm			::=	unitFactor {highPrecedenceQuantityOperator unitFactor} .
production kNewtonIrNodeType_PunitTerm:			followset = {
									followset(kNewtonIrNodeType_PunitExpression),
								}

--//		unitFactor			::=	(unit [exponentiationOperator numericFactor]) | "(" unitExpression ")" .
production kNewtonIrNodeType_PunitFactor:		followset = {
									kNewtonIrNodeType_Tsemicolon,
									firstset(kNewtonIrNodeType_PhighPrecedenceQuantityOperator),
									followset(kNewtonIrNodeType_PunitTerm),
									kNewtonIrNodeType_Tcomma,
									kNewtonIrNodeType_TrightBracket,
									followset(kNewtonIrNodeType_PuncertaintyStatement),
									followset(kNewtonIrNodeType_PerasureValueStatement),
								}

--//		unit				::=	identifier .
production kNewtonIrNodeType_Punit:			followset = {
									firstset(kNewtonIrNodeType_PexponentiationOperator),
									followset(kNewtonIrNodeType_PunitFactor),
								}

--//		numericExpression			::=	numericTerm {lowPrecedenceOperator numericTerm} .
production kNewtonIrNodeType_PnumericExpression:	followset = {
									kNewtonIrNodeType_TrightParen,
									kNewtonIrNodeType_Tcomma,
									kNewtonIrNodeType_TleftBracket,
									kNewtonIrNodeType_TrightBracket,
									kNewtonIrNodeType_Tto,
									followset(kNewtonIrNodeType_PreadRegisterCommand),
									followset(kNewtonIrNodeType_PwriteRegisterCommand),
									followset(kNewtonIrNodeType_PdelayCommand),
								}

--//		numericTerm			::=	numericFactor {highPrecedenceOperator numericFactor} .
production kNewtonIrNodeType_PnumericTerm:		followset = {
									firstset(kNewtonIrNodeType_PlowPrecedenceOperator),
									followset(kNewtonIrNodeType_PnumericExpression),
								}

--//		numericFactor			::=	(numericConst [exponentiationOperator numericConst]) | "(" numericExpression ")" .
production kNewtonIrNodeType_PnumericFactor:		followset = {
									firstset(kNewtonIrNodeType_PunitFactor),
									kNewtonIrNodeType_Tsemicolon,
									kNewtonIrNodeType_TatSign,
									followset(kNewtonIrNodeType_PunitFactor),
									firstset(kNewtonIrNodeType_PhighPrecedenceOperator),
									followset(kNewtonIrNodeType_PnumericTerm),
									kNewtonIrNodeType_Tbits,
									kNewtonIrNodeType_Tcomma,
									kNewtonIrNodeType_TrightBracket,
									followset(kNewtonIrNodeType_PerasureValueStatement),
									kNewtonIrNodeType_TrightParen,
									kNewtonIrNodeType_Tsemicolon,
								}

--//		sensorPropertyList		::=	sensorProperty {"," sensorProperty} .
production kNewtonIrNodeType_PsensorPropertyList:	followset = {
									kNewtonIrNodeType_TrightBrace,
								}

--//		sensorProperty			::=	rangeStatement | uncertaintyStatement | erasureValueStatement | accuracyStatement | precisionStatement | sensorInterfaceStatement .
production kNewtonIrNodeType_PsensorProperty:		followset = {
									kNewtonIrNodeType_Tcomma,
									followset(kNewtonIrNodeType_PsensorPropertyList),
								}

--//		sensorInterfaceStatement	::=	"interface" identifier ["@" numericFactor "bits"] "==" sensorInterfaceType [parameterTuple ["{" sensorInterfaceCommandList "}"]] .
production kNewtonIrNodeType_PsensorInterfaceStatement:	followset = {
									followset(kNewtonIrNodeType_PsensorProperty),
								}

--//		sensorInterfaceType		::=	"i2c" | "spi" | "analog" .
production kNewtonIrNodeType_PsensorInterfaceType:	followset = {
									followset(kNewtonIrNodeType_PsensorInterfaceStatement),
									firstset(kNewtonIrNodeType_PparameterTuple),
								}

--//		sensorInterfaceCommandList	::=	sensorInterfaceCommand ";" {sensorInterfaceCommand ";"} .
production kNewtonIrNodeType_PsensorInterfaceCommandList:	followset = {
									kNewtonIrNodeType_TrightBrace,
								}

--//		sensorInterfaceCommand		::=	readRegisterCommand | writeRegisterCommand | delayCommand | arithmeticCommand .
production kNewtonIrNodeType_PsensorInterfaceCommand:	followset = {
									kNewtonIrNodeType_Tsemicolon,
									followset(kNewtonIrNodeType_PsensorInterfaceCommandList),
								}

--//		readRegisterCommand		::=	identifier "=" "read" ["[" numericExpression "]" ","] numericExpression .
production kNewtonIrNodeType_PreadRegisterCommand:	followset = {
									followset(kNewtonIrNodeType_PsensorInterfaceCommand),
								}

--//		writeRegisterCommand		::=	"write" numericExpression "," numericExpression .
production kNewtonIrNodeType_PwriteRegisterCommand:	followset = {
									followset(kNewtonIrNodeType_PsensorInterfaceCommand),
								}

--//		delayCommand			::=	"delay" numericExpression .
production kNewtonIrNodeType_PdelayCommand:		followset = {
									followset(kNewtonIrNodeType_PsensorInterfaceCommand),
								}

--//		arithmeticCommand		::=	identifier "=" expression .
production kNewtonIrNodeType_ParithmeticCommand:	followset = {
									followset(kNewtonIrNodeType_PsensorInterfaceCommand),
								}

--//		rangeStatement			::=	"range" identifier "==" "[" numericFactor [unitFactor] "," numericFactor [unitFactor] "]" .
production kNewtonIrNodeType_PrangeStatement:		followset = {
									followset(kNewtonIrNodeType_PsensorProperty),
								}

--//		uncertaintyStatement		::=	"uncertainty" identifier "==" factor [unitFactor] .
production kNewtonIrNodeType_PuncertaintyStatement:	followset = {
									followset(kNewtonIrNodeType_PsensorProperty),
								}

--//		erasureValueStatement		::=	"erasuretoken" identifier "==" numericFactor [unitFactor] .
production kNewtonIrNodeType_PerasureValueStatement:	followset = {
									followset(kNewtonIrNodeType_PsensorProperty),
								}

--//		accuracyStatement		::=	"accuracy" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_PaccuracyStatement:	followset = {
									followset(kNewtonIrNodeType_PsensorProperty),
								}

--//		precisionStatement		::=	"precision" identifier "==" numericConstTupleList .
production kNewtonIrNodeType_PprecisionStatement:	followset = {
									followset(kNewtonIrNodeType_PsensorProperty),
								}

--//		numericConstTupleList		::=	"{" numericConstTuple {"," numericConstTuple} "}" .
production kNewtonIrNodeType_PnumericConstTupleList:	followset = {
									followset(kNewtonIrNodeType_PaccuracyStatement),
									followset(kNewtonIrNodeType_PprecisionStatement),
								}

--//		numericConstTuple		::=	"(" numericFactor [unitFactor] "," numericFactor ")" .
production kNewtonIrNodeType_PnumericConstTuple:	followset = {
									kNewtonIrNodeType_Tcomma,
									followset(kNewtonIrNodeType_PnumericConstTupleList),
								}

--//		expression			::=	term {lowPrecedenceBinaryOp term} .
production kNewtonIrNodeType_Pexpression:		followset = {
									followset(kNewtonIrNodeType_ParithmeticCommand),
									kNewtonIrNodeType_Tcomma,
									kNewtonIrNodeType_TrightParen,
								}

--//		term				::=	[unaryOp] factor ["++" | "--"] {highPrecedenceBinaryOp factor} .
production kNewtonIrNodeType_Pterm:			followset = {
									firstset(kNewtonIrNodeType_PlowPrecedenceBinaryOp),
									followset(kNewtonIrNodeType_Pexpression)
								}

--//		factor				::=	numericConst | "(" expression ")" | distributionFactor | identifier ["[" numericExpression "]"] .
production kNewtonIrNodeType_Pfactor:			followset = {
									kNewtonIrNodeType_TplusPlus,
									kNewtonIrNodeType_TminusMinus,
									firstset(kNewtonIrNodeType_PhighPrecedenceBinaryOp),
									followset(kNewtonIrNodeType_Pterm),
									firstset(kNewtonIrNodeType_PunitFactor),
								}

--//		distributionFactor		::=	distribution parameterValueList .
production kNewtonIrNodeType_PdistributionFactor:	followset = {
									followset(kNewtonIrNodeType_Pfactor)
									firstset(kNewtonIrNodeType_PparameterTuple)
								}

--//		parameterValueList		::=	"(" identifier ":" expression {"," identifier ":" expression} ")" .
production kNewtonIrNodeType_PparameterValueList:	followset = {
									followset(kNewtonIrNodeType_PdistributionFactor)
								}

--//		distribution			::=	 "Gaussian" | "Laplacian" | "StudentT" | "Bernoulli" | "Binomial" 
--//							| "Poisson" | "NegativeBinomial" | "BetaBinomial" | "Exponential"
--//							| "Gamma" | "Multinomial" | "Beta" | "LogitNormal" | "Dirichlet"
--//							| "Cauchy" | "LogNormal" | "Pareto" | "BetaPrime" | "StudentZ" 
--//							| "Weibull" | "Erlang" | "Maxwell" | "FermiDirac" | "FisherZ" 
--//							| "LogSeries" | "Gumbel" | "Rayleigh" | "Gibrat" | "PearsonIII"
--//							| "ExtremeValue" | "F" | "Xi" | "XiSquared" .
production kNewtonIrNodeType_Pdistribution:		followset = {
									kNewtonIrNodeType_TleftParen,
									firstset(kNewtonIrNodeType_PparameterTuple),
									firstset(kNewtonIrNodeType_PparameterValueList),
								}

--//		transcendental			::= "sin" | "cos" | "tan"
--//								| "arcsin" | "arccos" | "arctan"
--//								| "sinh" | "cosh" | "tanh"
--//								| "exp" | "sqrt"
--//								| "ln" | "log10" | "log2" .
production kNewtonIrNodeType_Ptranscendental:	followset = {
									kNewtonIrNodeType_TleftParen
								}

--//		highPrecedenceBinaryOp		::=	"*" | "/" | "%" | "**" .
production kNewtonIrNodeType_PhighPrecedenceBinaryOp:	followset = {
									firstset(kNewtonIrNodeType_Pfactor)
								}

--//		lowPrecedenceBinaryOp		::=	"+" | "-" | ">>" | "<<" | "|" .
production kNewtonIrNodeType_PlowPrecedenceBinaryOp:	followset = {
									firstset(kNewtonIrNodeType_Pterm)
								}

--//		unaryOp				::=	"-"  | "+" .
production kNewtonIrNodeType_PunaryOp:			followset = {
									firstset(kNewtonIrNodeType_Pfactor),
									firstset(kNewtonIrNodeType_PquantityFactor),
								}




token	kNewtonIrNodeType_TEnglish:			followset = {
									}
token	kNewtonIrNodeType_Taccuracy:			followset = {
									}
token	kNewtonIrNodeType_Tanalog:			followset = {
									}
token	kNewtonIrNodeType_TatSign:			followset = {
									}
token	kNewtonIrNodeType_Tcolon:			followset = {
									}
token	kNewtonIrNodeType_Tcomma:			followset = {
									}
token	kNewtonIrNodeType_Tconstant:			followset = {
									}
token	kNewtonIrNodeType_Tcross:			followset = {
									}
token	kNewtonIrNodeType_Tdelay:			followset = {
									}
token	kNewtonIrNodeType_Tderivation:			followset = {
									}
token	kNewtonIrNodeType_Tderivative:			followset = {
									}
token	kNewtonIrNodeType_Tdiv:				followset = {
									}
token	kNewtonIrNodeType_Tdimensionless:		followset = {
									}
token	kNewtonIrNodeType_Tdot:				followset = {
									}
token	kNewtonIrNodeType_Tequals:			followset = {
									}
token	kNewtonIrNodeType_TdimensionallyMatchingProportional:	followset = {
									}
token	kNewtonIrNodeType_TerasureToken:		followset = {
									}
token	kNewtonIrNodeType_Texponentiation:		followset = {
									}
token	kNewtonIrNodeType_TGaussian:			followset = {
									}
token	kNewtonIrNodeType_TBernoulli:			followset = {
									}
token	kNewtonIrNodeType_TBinomial:			followset = {
									}
token	kNewtonIrNodeType_TPoisson:			followset = {
									}
token	kNewtonIrNodeType_TNegativeBinomial:		followset = {
									}
token	kNewtonIrNodeType_TBetaBinomial:		followset = {
									}
token	kNewtonIrNodeType_TExponential:			followset = {
									}
token	kNewtonIrNodeType_TGamma:			followset = {
									}
token	kNewtonIrNodeType_TMultinomial:			followset = {
									}
token	kNewtonIrNodeType_TBeta:			followset = {
									}
token	kNewtonIrNodeType_TLogitNormal:			followset = {
									}
token	kNewtonIrNodeType_TDirichlet:			followset = {
									}
token	kNewtonIrNodeType_TCauchy:			followset = {
									}
token	kNewtonIrNodeType_TLogNormal:			followset = {
									}
token	kNewtonIrNodeType_TPareto:			followset = {
									}
token	kNewtonIrNodeType_TBetaPrime:			followset = {
									}
token	kNewtonIrNodeType_TStudentZ:			followset = {
									}
token	kNewtonIrNodeType_TWeibull:			followset = {
									}
token	kNewtonIrNodeType_TErlang:			followset = {
									}
token	kNewtonIrNodeType_TMaxwell:			followset = {
									}
token	kNewtonIrNodeType_TFermiDirac:			followset = {
									}
token	kNewtonIrNodeType_TFisherZ:			followset = {
									}
token	kNewtonIrNodeType_TLogSeries:			followset = {
									}
token	kNewtonIrNodeType_TGumbel:			followset = {
									}
token	kNewtonIrNodeType_TRayleigh:			followset = {
									}
token	kNewtonIrNodeType_TGibrat:			followset = {
									}
token	kNewtonIrNodeType_TPearsonIII:			followset = {
									}
token	kNewtonIrNodeType_TExtremeValue:		followset = {
									}
token	kNewtonIrNodeType_TF:				followset = {
									}
token	kNewtonIrNodeType_TXi:				followset = {
									}
token	kNewtonIrNodeType_TXiSquared:			followset = {
									}
token	kNewtonIrNodeType_TUnconstrained:			followset = {
									}
token	kNewtonIrNodeType_Tsin:			followset = {
									}
token	kNewtonIrNodeType_Tcos:			followset = {
									}
token	kNewtonIrNodeType_Ttan:			followset = {
									}
token	kNewtonIrNodeType_Tcotan:			followset = {
									}
token	kNewtonIrNodeType_Tsec:			followset = {
									}
token	kNewtonIrNodeType_Tcosec:			followset = {
									}
token	kNewtonIrNodeType_Tarcsin:			followset = {
									}
token	kNewtonIrNodeType_Tarccos:			followset = {
									}
token	kNewtonIrNodeType_Tarctan:			followset = {
									}
token	kNewtonIrNodeType_Tarccotan:			followset = {
									}
token	kNewtonIrNodeType_Tarcsec:			followset = {
									}
token	kNewtonIrNodeType_Tarccosec:			followset = {
									}
token	kNewtonIrNodeType_Tsinh:			followset = {
									}
token	kNewtonIrNodeType_Tcosh:			followset = {
									}
token	kNewtonIrNodeType_Ttanh:			followset = {
									}
token	kNewtonIrNodeType_Tcotanh:			followset = {
									}
token	kNewtonIrNodeType_Tsech:			followset = {
									}
token	kNewtonIrNodeType_Tcosech:			followset = {
									}
token	kNewtonIrNodeType_Tarcsinh:			followset = {
									}
token	kNewtonIrNodeType_Tarccosh:			followset = {
									}
token	kNewtonIrNodeType_Tarctanh:			followset = {
									}
token	kNewtonIrNodeType_Tarccotanh:			followset = {
									}
token	kNewtonIrNodeType_Tarcsech:			followset = {
									}
token	kNewtonIrNodeType_Tarccosech:			followset = {
									}
token	kNewtonIrNodeType_Texp:			followset = {
									}
token	kNewtonIrNodeType_Tsqrt:			followset = {
									}
token	kNewtonIrNodeType_Tln:			followset = {
									}
token	kNewtonIrNodeType_Tlog10:			followset = {
									}
token	kNewtonIrNodeType_Tlog2:			followset = {
									}
token	kNewtonIrNodeType_Tge:				followset = {
									}
token	kNewtonIrNodeType_Tgt:				followset = {
									}
token	kNewtonIrNodeType_Ti2c:				followset = {
									}
token	kNewtonIrNodeType_Tintegral:			followset = {
									}
token	kNewtonIrNodeType_Tinterface:			followset = {
									}
token	kNewtonIrNodeType_Tinvariant:			followset = {
									}
token	kNewtonIrNodeType_Tle:				followset = {
									}
token	kNewtonIrNodeType_TleftBrace:			followset = {
									}
token	kNewtonIrNodeType_TleftParen:			followset = {
									}
token	kNewtonIrNodeType_TleftShift:			followset = {
									}
token	kNewtonIrNodeType_Tlt:				followset = {
									}
token	kNewtonIrNodeType_TLaplacian:			followset = {
									}
token	kNewtonIrNodeType_Tminus:			followset = {
									}
token	kNewtonIrNodeType_Tmul:				followset = {
									}
token	kNewtonIrNodeType_Tmutualinf:			followset = {
									}
token	kNewtonIrNodeType_Tname:			followset = {
									}
token	kNewtonIrNodeType_Tnil:				followset = {
									}
token	kNewtonIrNodeType_Tnone:			followset = {
									}
token	kNewtonIrNodeType_Tplus:			followset = {
									}
token	kNewtonIrNodeType_Tprecision:			followset = {
									}
token	kNewtonIrNodeType_TdimensionallyAgnosticProportional:followset = {
									}
token	kNewtonIrNodeType_Trange:			followset = {
									}
token	kNewtonIrNodeType_Tread:			followset = {
									}
token	kNewtonIrNodeType_Trelated:			followset = {
									}
token	kNewtonIrNodeType_TrightBrace:			followset = {
									}
token	kNewtonIrNodeType_TrightParen:			followset = {
									}
token	kNewtonIrNodeType_TrightShift:			followset = {
									}
token	kNewtonIrNodeType_Tsemicolon:			followset = {
									}
token	kNewtonIrNodeType_Tsensor:			followset = {
									}
token	kNewtonIrNodeType_Tsignal:			followset = {
									}
token	kNewtonIrNodeType_Tsignal:			followset = {
									}
token	kNewtonIrNodeType_Tspi:				followset = {
									}
token	kNewtonIrNodeType_Tsymbol:			followset = {
									}
token	kNewtonIrNodeType_TStudentT:			followset = {
									}
token	kNewtonIrNodeType_Tto:				followset = {
									}
token	kNewtonIrNodeType_Tuncertainty:			followset = {
									}
token	kNewtonIrNodeType_Twrite:			followset = {
									}
token	kNewtonIrNodeType_Tbits:			followset = {
									}
token	kNewtonIrNodeType_Tdimensionless:		followset = {
									}
token	kNewtonIrNodeType_TdotDot:			followset = {
									}
token	kNewtonIrNodeType_TplusPlus:			followset = {
									}
token	kNewtonIrNodeType_TminusMinus:			followset = {
									}
token	kNewtonIrNodeType_Tassign:			followset = {
									}
token	kNewtonIrNodeType_Tdef:				followset = {
									}
token	kNewtonIrNodeType_Tinclude:			followset = {
									}
token	kNewtonIrNodeType_TleftBracket:			followset = {
									}
token	kNewtonIrNodeType_TrightBracket:		followset = {
									}
token	kNewtonIrNodeType_TbitwiseOr:			followset = {
									}
token	kNewtonIrNodeType_Tpercent:			followset = {
									}
token kNewtonIrNodeType_TrightArrow:			followset = {
									}
token kNewtonIrNodeType_Tpiecewise:			followset = {
									}
token kNewtonIrNodeType_Tcase:				followset = {
									}
token kNewtonIrNodeType_Totherwise:			followset = {
									}
token	kNewtonIrNodeType_TintegerConst:		followset = {
									}
token	kNewtonIrNodeType_TrealConst:			followset = {
									}
token	kNewtonIrNodeType_TstringConst:			followset = {
									}
token	kNewtonIrNodeType_Tidentifier:			followset = {
									}
