/*
 *	Lexical elements
 */
reservedIdentifiers		::=	":" | "," | "@" | "o<" | "~" | "<" | "<=" | ">" | ">=" | "==" | "<->"
					| "**" | "*" | "/" | "+" | "-" | "<<" | ">>" | "|" | "++" | "--"
					| "-" | "English" | "constant" | "invariant" | "signal"
					| "sensor" | "name" | "symbol" | "derivation" | "none"
					| "dot" | "cross" | "derivative" | "integral" | "interface"
					| "i2c" | "spi" | "analog" | "write" | "read" | "delay" | "range"
					| "erasuretoken" | "uncertainty" | "accuracy" | "precision"
					| "Gaussian" | "Laplacian" | "StudentT" | "Bernoulli" | "Binomial" 
					| "Poisson" | "NegativeBinomial" | "BetaBinomial" | "Exponential"
					| "Gamma" | "Multinomial" | "Beta" | "LogitNormal" | "Dirichlet"
					| "Cauchy" | "LogNormal" | "Pareto" | "BetaPrime" | "StudentZ" 
					| "Weibull" | "Erlang" | "Maxwell" | "FermiDirac" | "FisherZ" 
					| "LogSeries" | "Gumbel" | "Rayleigh" | "Gibrat" | "PearsonIII"
					| "ExtremeValue"| "F" | "Xi" | "XiSquared" | "to" | "bits" | "><"
					| "dimensionless" | "include" | "(" | ")" | "{" | "}" | ";" | ".." .

zeroToNine			=	"0-9" .
oneToNine			=	"1-9" .
radix				=	oneToNine {zeroToNine} "r" .
charConst			=	"'" character "'" .
integerConst			::=	["+" | "-"] [radix] ("0" | oneToNine {zeroToNine}) | charConst .
drealConst			=	("0" | oneToNine {zeroToNine}) "." {zeroToNine} .
erealConst			=	(drealConst | integerConst) ("e" | "E") integerConst .
realConst			::=	["+" | "-"] (drealConst | erealConst) .
stringConst			::=	'"' {character} '"' .
idchar				=	char-except-rsvopseptoken .
identifier			::=	(idchar-except-zeroToNine) {idchar} .

/*
 *	Syntactic elements. The language grammar is purposefully stricter than it needs
 *	to be based purely on the standard operator precedence rules: In many places
 *	the grammar purposefully requires a `factor` when a `term` would be acceptable
 *	based on operator precedence. For example, for `constantDefinition` production,
 *	rather than
 *
 *		constantDefinition	::=	identifier ":" "constant" "=" numericTerm [unitExpression] ";" .
 *
 *	the language requires the constant value to be a `factor` (a single constant
 *	or a term/expression in parentesis):
 *
 *		constantDefinition	::=	identifier ":" "constant" "=" numericFactor [unitFactor] ";" .
 */
newtonDescription		::=	ruleList .
ruleList			::=	{rule} .
rule				::=	constantDefinition | invariantDefinition | baseSignalDefinition | sensorDefinition .
constantDefinition		::=	identifier ":" "constant" "=" numericFactor [unitFactor] ";" .
invariantDefinition		::=	identifier ":" "invariant" parameterTuple  "=" "{" constraintList "}" .
baseSignalDefinition		::=	identifier ":" "signal" [subdimensionTuple] "=" "{" [nameStatement] symbolStatement derivationStatement "}" .
sensorDefinition		::=	identifier ":" "sensor" parameterTuple "=" "{" sensorPropertyList "}" .
nameStatement			::=	"name" "=" stringConst languageSetting ";" .
symbolStatement			::=	"symbol" "=" identifier ";" .
derivationStatement		::=	"derivation" "=" ("none" | "dimensionless" | quantityExpression) ";" .
subdimensionTuple		::=	"(" identifier ":" numericExpression "to" numericExpression ")" .
parameterTuple			::=	"(" parameter {"," parameter} ")" .
parameter			::=	identifier ":" identifier {"@" integerConst} .
constraintList			::=	[constraint] {"," constraint} .
constraint			::=	quantityExpression comparisonOperator quantityExpression | identifier parameterTuple .
quantityExpression		::=	quantityTerm {lowPrecedenceOperator quantityTerm} .
quantityTerm			::=	[unaryOp] quantityFactor {highPrecedenceQuantityOperator quantityFactor} .
quantityFactor			::=	quantity [exponentiationOperator quantityFactor]						|
						functionalOperator {functionalOperator} quantityFactor quantityFactor			|
						"(" quantityExpression ")" 								|
						"{" quantityExpression {"," quantityExpression} "}" .
/*
 *	The following needs to be
 *
 *			numericConst | (identifier {"@" numericFactor}) .
 *
 *	and not
 *
 *			numericFactor | (identifier {"@" numericFactor}) .
 *
 *	because the latter would lead to an ambiguity in parsing quantityFactor
 */
quantity			::=	numericConst | (identifier {"@" numericFactor}) .
highPrecedenceQuantityOperator	::=	highPrecedenceOperator | vectorOp | "><" .
lowPrecedenceOperator		::=	"+" | "-" .
highPrecedenceOperator		::=	"*" | "/" .
exponentiationOperator		::=	"**" .
vectorOp			::=	"dot" | "cross" .
functionalOperator		::=	"derivative" | "integral" .
comparisonOperator		::=	"o<" | "~" | "<" | "<=" | ">" | ">=" | "==" | "<->" .
languageSetting			::=	"English" .
unitExpression			::=	unitTerm .
unitTerm			::=	unitFactor {highPrecedenceOperator unitFactor} .
unitFactor			::=	(unit [exponentiationOperator numericFactor]) | "(" unitExpression ")" .
unit				::=	identifier .
numericExpression		::=	numericTerm {lowPrecedenceOperator numericTerm} .
numericTerm			::=	numericFactor {highPrecedenceOperator numericFactor} .
numericFactor			::=	(numericConst [exponentiationOperator numericConst]) | "(" numericExpression ")" .
sensorPropertyList		::=	sensorProperty {"," sensorProperty} .
sensorProperty			::=	rangeStatement | uncertaintyStatement | erasureValueStatement | accuracyStatement | precisionStatement | sensorInterfaceStatement .
sensorInterfaceStatement	::=	"interface" identifier ["@" numericFactor "bits"] "==" sensorInterfaceType parameterTuple ["{" sensorInterfaceCommandList "}"] .
sensorInterfaceType		::=	"i2c" | "spi" | "analog" .
sensorInterfaceCommandList	::=	sensorInterfaceCommand {";" sensorInterfaceCommand} .
sensorInterfaceCommand		::=	readRegisterCommand | writeRegisterCommand | delayCommand | arithmeticCommand .
readRegisterCommand		::=	identifier "=" "read" ["[" numericExpression "]" ","] numericExpression .
writeRegisterCommand		::=	"write" numericExpression "," numericExpression .
delayCommand			::=	"delay" numericExpression .
arithmeticCommand		::=	identifier "=" expression .
rangeStatement			::=	"range" identifier "==" "[" numericFactor [unitFactor] "," numericFactor [unitFactor] "]" .
uncertaintyStatement		::=	"uncertainty" identifier "==" factor [unitFactor] .
erasureValueStatement		::=	"erasuretoken" identifier "==" numericFactor [unitFactor] .
accuracyStatement		::=	"accuracy" identifier "==" numericConstTupleList .
precisionStatement		::=	"precision" identifier "==" numericConstTupleList .
numericConstTupleList		::=	"{" numericConstTuple {"," numericConstTuple} "}" .
numericConstTuple		::=	"(" numericFactor [unitFactor] "," numericFactor ")" .
numericConst			::=	integerConst | realConst .
expression			::=	term {lowPrecedenceBinaryOp term} .
term				::=	[unaryOp] factor ["++" | "--"] {highPrecedenceBinaryOp factor} .
factor				::=	numericConst | "(" expression ")" | distributionFactor | identifier ["[" yy numericExpression "]"] .
distributionFactor		::=	distribution parameterValueList .
parameterValueList		::=	"(" identifier ":" expression {"," identifier ":" expression} ")" .
distribution			::=	"Gaussian" | "Laplacian" | "StudentT" | "Bernoulli" | "Binomial" 
					| "Poisson" | "NegativeBinomial" | "BetaBinomial" | "Exponential"
					| "Gamma" | "Multinomial" | "Beta" | "LogitNormal" | "Dirichlet"
					| "Cauchy" | "LogNormal" | "Pareto" | "BetaPrime" | "StudentZ" 
					| "Weibull" | "Erlang" | "Maxwell" | "FermiDirac" | "FisherZ" 
					| "LogSeries" | "Gumbel" | "Rayleigh" | "Gibrat" | "PearsonIII"
					| "ExtremeValue" | "F" | "Xi" | "XiSquared" .
highPrecedenceBinaryOp		::=	"*" | "/" | "%" | "**" .
lowPrecedenceBinaryOp		::=	"+" | "-" | ">>" | "<<" | "|" .
unaryOp				::=	"-"  | "+" .
