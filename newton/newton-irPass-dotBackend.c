/*
	Authored 2017. Phillip Stanley-Marbell. Jonathan Lim


	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	*	Redistributions of source code must retain the above
		copyright notice, this list of conditions and the following
		disclaimer.

	*	Redistributions in binary form must reproduce the above
		copyright notice, this list of conditions and the following
		disclaimer in the documentation and/or other materials
		provided with the distribution.

	*	Neither the name of the author nor the names of its
		contributors may be used to endorse or promote products
		derived from this software without specific prior written
		permission.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
*/
#include <stdio.h>
#include <stdbool.h>
#include <assert.h>
#include <stdlib.h>
#include <setjmp.h>
#include <sys/time.h>
#include <string.h>
#include <stdint.h>
#include "flextypes.h"
#include "flexerror.h"
#include "flex.h"
#include "common-errors.h"
#include "version.h"
#include "common-timeStamps.h"
#include "data-structures.h"
#include "noisy-parser.h"
#include "noisy-lexer.h"
#include "common-irPass-helpers.h"
#include "newton-types.h"



static bool	isType(NoisyState *  N, NoisyIrNode *  node);
static char *	scope2id(NoisyState *  N, NoisyScope *  scope);
static char *	scope2id2(NoisyState *  N, NoisyScope *  scope);
static char *	symbol2id(NoisyState *  N, NoisySymbol *  symbol);


int
irPassDotAstDotFmt(NoisyState *  N, char *  buf, int bufferLength, NoisyIrNode *  irNode, char* astNodeStrings[])
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassDotAstDotFmt);

	char *		nilFormatString;
	char *		tokenString = "";
	char *		typeString;
	char *		l;
	char *		nodeBorderString;
	char *		nodePropertiesString;
	char *		r;
	char *		src;
	int		n = 0;


	/*
	 *	TODO: if we run out of space in print buffer, we should
	 *	print a "..." rather than just ending like we do now.
	 */

	if (irNode->tokenString != NULL)
	{
		tokenString = irNode->tokenString;
	}

	/*
	 *	We use the pointer address of the NoisyIrNode *  p to give a unique
	 *	string for each node in the graph. NOTE: dot renders _much_ faster
	 *	if we don't supply a fontname (which it often cannot find anyway)...
	 */
	nilFormatString		= "style=filled,color=\"#003333\",fontcolor=white,fontname=\"LucidaSans-Typewriter\",fontsize=8,width=0.3,height=0.16,fixedsize=true,label=\"nil\", shape=record";
	nodePropertiesString	= "";
	nodeBorderString	= "M";
	typeString		= astNodeStrings[irNode->type];

	/*
	 *	For identifiers, different graph node properties
	 */
	if (irNode->type == kNewtonIrNodeType_Tidentifier)
	{
		nodePropertiesString = "style=filled,color=\"#ccff66\",";
		nodeBorderString = "";
	}

	/*
	 *	For X_SEQ, different graph node properties
	 */
	if (irNode->type == kNoisyIrNodeType_Xseq)
	{
		nodePropertiesString = "style=filled,color=\"#999999\",fixedsize=true,";
		nodeBorderString = "M";

		/*
		 *	X_SEQ is not part of gASTnodeSTRINGS, which is generated by our
		 *	ffi2code tools.
		 */
		typeString = "X_SEQ";
	}

	src = (char *) calloc(kNoisyMaxPrintBufferLength, sizeof(char));
	if (src == NULL)
	{
		noisyFatal(N, Emalloc);
	}

	if (irNode->type != kNoisyIrNodeType_Xseq)
	{
		snprintf(src, kNoisyMaxPrintBufferLength, "| source:%llu,%llu", irNode->sourceInfo->lineNumber, irNode->sourceInfo->columnNumber);
	}

	if (N->dotDetailLevel & kNoisyDotDetailLevelNoText)
	{
		n += snprintf(&buf[n], bufferLength,
			"\tP" FLEX_PTRFMTH " [%sfontsize=8,fontname=\"LucidaSans-Typewriter\",height=0.8,"
			"label=\"{ | {<left> | <right> }}\",shape=%srecord];\n",
			(FlexAddr)irNode, nodePropertiesString, nodeBorderString);
	}
	else
	{
		n += snprintf(&buf[n], bufferLength,
                  "\tP" FLEX_PTRFMTH " [%sfontsize=8,height=0.8,fontname=\"LucidaSans-Typewriter\","
                  "label=\"{P" FLEX_PTRFMTH "\\ntype=%s\\n%s%s\\n%s %s%s%s| {<left> | <right> }}\",shape=%srecord];\n",
                  (FlexAddr)irNode, nodePropertiesString, (FlexAddr)irNode, typeString,
                  ((tokenString == NULL || ((size_t) strlen(tokenString)) == 0) ? "" : " tokenString="), tokenString,
                  src, (isType(N, irNode) ? "#" : ""), (isType(N, irNode) ? newtonTypeMakeTypeSignature(N, irNode) : ""), (isType(N, irNode) ? "#" : ""), nodeBorderString);
	}

	bufferLength -= n;

	if (!(N->dotDetailLevel & kNoisyDotDetailLevelNoNilNodes) && (L(irNode) == NULL))
	{
		n += snprintf(&buf[n], bufferLength, "\tP" FLEX_PTRFMTH "_leftnil [%s];\n",
			(FlexAddr)irNode, nilFormatString);
		bufferLength -= n;
	}
	if (!(N->dotDetailLevel & kNoisyDotDetailLevelNoNilNodes) && (R(irNode) == NULL))
	{
		n += snprintf(&buf[n], bufferLength, "\tP" FLEX_PTRFMTH "_rightnil [%s];\n",
			(FlexAddr)irNode, nilFormatString);
		bufferLength -= n;
	}

	l = (char *)calloc(kNoisyMaxPrintBufferLength, sizeof(char));
	if (l == NULL)
	{
		noisyFatal(N, Emalloc);
	}

	r = (char *)calloc(kNoisyMaxPrintBufferLength, sizeof(char));
	if (r == NULL)
	{
		noisyFatal(N, Emalloc);
	}

	if (!(N->dotDetailLevel & kNoisyDotDetailLevelNoNilNodes) && (L(irNode) == NULL))
	{
		snprintf(l, kNoisyMaxPrintBufferLength, "P" FLEX_PTRFMTH "_leftnil", (FlexAddr)irNode);
	}
	else if (L(irNode) != NULL)
	{
		snprintf(l, kNoisyMaxPrintBufferLength, "P" FLEX_PTRFMTH "", (FlexAddr)L(irNode));
	}

	if (!(N->dotDetailLevel & kNoisyDotDetailLevelNoNilNodes) && (R(irNode) == NULL))
	{
		snprintf(r, kNoisyMaxPrintBufferLength, "P" FLEX_PTRFMTH "_rightnil", (FlexAddr)irNode);
	}
	else if (R(irNode) != NULL)
	{
		snprintf(r, kNoisyMaxPrintBufferLength, "P" FLEX_PTRFMTH, (FlexAddr)R(irNode));
	}

	if (strlen(l))
	{
		n += snprintf(&buf[n], bufferLength, "\tP" FLEX_PTRFMTH ":left -> %s;\n", (FlexAddr)irNode, l);
		bufferLength -= n;
	}

	if (strlen(r))
	{
		n += snprintf(&buf[n], bufferLength, "\tP" FLEX_PTRFMTH ":right -> %s;\n", (FlexAddr)irNode, r);
		bufferLength -= n;
	}

	USED(bufferLength);
	free(l);
	free(r);
	free(src);


	return n;
}


int
irPassDotSymbolTableDotFmt(NoisyState *  N, char *  buf, int bufferLength, NoisyScope *  scope)
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassDotSymbotTableDotFmt);

	char *		nilFormatString;
	char *		symbolFormatString;
	int		n = 0;


	/*
	 *	TODO: if we run out of space in print buffer, we should
	 *	print a "..." rather than just ending like we do now.
	 */

	nilFormatString		= "style=filled,color=\"#000000\",fontcolor=white,fontsize=8,width=0.3,height=0.16,fixedsize=true,fontname=\"LucidaSans-Typewriter\",label=\"nil\", shape=record";
	symbolFormatString	= "style=filled,color=\"#dddddd\",fontcolor=black,fontsize=8,height=0.16,fontname=\"LucidaSans-Typewriter\", shape=record";

	n += snprintf(	&buf[n], bufferLength, "\tscope%s [style=filled,color=\"#FFCC00\",fontname=\"LucidaSans-Typewriter\",fontsize=8,height=0.8,label=\"{%s | {<children> | <syms>}}\",shape=record];\n",
			scope2id(N, scope), scope2id2(N, scope));
	bufferLength -= n;

	if (scope->firstChild == NULL)
	{
		n += snprintf(&buf[n], bufferLength, "\tscope%s_kidsnil [%s];\n", scope2id(N, scope), nilFormatString);
		bufferLength -= n;
	}
	if (scope->firstSymbol == NULL)
	{
		n += snprintf(&buf[n], bufferLength, "\tscope%s_symsnil [%s];\n", scope2id(N, scope), nilFormatString);
		bufferLength -= n;
	}

	NoisyScope *	childScope  = scope->firstChild;
	while (childScope != NULL)
	{
		n += snprintf(	&buf[n], bufferLength, "\tscope%s [style=filled,color=\"#FFCC00\",fontname=\"LucidaSans-Typewriter\",fontsize=8,height=0.8,label=\"{%s | {<children> | <syms>}}\",shape=record];\n",
				scope2id(N, childScope), scope2id2(N, childScope));
		bufferLength -= n;

		childScope = childScope->next;
	}

	NoisySymbol *	childSymbol = scope->firstSymbol;
	while (childSymbol != NULL)
	{
		n += snprintf(&buf[n], bufferLength, "\tsym%s [%s,label=\"{%s}\",shape=rect];\n",
			symbol2id(N, childSymbol), symbolFormatString, childSymbol->identifier);
		bufferLength -= n;

		childSymbol = childSymbol->next;
	}


	if (scope->firstChild == NULL)
	{
		n += snprintf(&buf[n], bufferLength, "\tscope%s:children -> scope%s_kidsnil;\n", scope2id(N, scope), scope2id(N, scope));
		bufferLength -= n;
	}
	else
	{
		childScope  = scope->firstChild;
		while (childScope != NULL)
		{
			n += snprintf(&buf[n], bufferLength, "\tscope%s:children -> scope%s;\n", scope2id(N, scope), scope2id(N, childScope));
			bufferLength -= n;
			
			childScope = childScope->next;
		}
	}

	if (scope->firstSymbol == NULL)
	{
		n += snprintf(&buf[n], bufferLength, "\tscope%s:syms -> scope%s_symsnil;\n", scope2id(N, scope), scope2id(N, scope));
		bufferLength -= n;
	}
	else
	{
		childSymbol = scope->firstSymbol;
		n += snprintf(&buf[n], bufferLength, "\tscope%s:syms -> sym%s;\n", scope2id(N, scope), symbol2id(N, childSymbol));
		bufferLength -= n;

		while (childSymbol != NULL && childSymbol->next != NULL)
		{
			n += snprintf(&buf[n], bufferLength, "\tsym%s:syms -> sym%s;\n", symbol2id(N, childSymbol), symbol2id(N, childSymbol->next));
			bufferLength -= n;
			childSymbol = childSymbol->next;
		}
	}
	USED(bufferLength);

	return n;
}


int
irPassDotAstPrintWalk(NoisyState *  N, NoisyIrNode *  irNode, char *  buf, int bufferLength, char* astNodeStrings[])
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassAstDotPrintWalk);

	int	n0 = 0, n1 = 0, n2 = 0;

	if (irNode == NULL)
	{
		return 0;
	}

	if (L(irNode) == irNode || R(irNode) == irNode)
	{
		noisyFatal(N, "Immediate cycle in Ir, seen noisyIrPassAstDotPrintWalk()!!\n");

		/*
		 *	Not reached
		 */
		return 0;
	}

	/*
	 *	For DOT, we walk tree in postorder, though it doesn't matter
	 *	either way.
	 */
	n0 = irPassDotAstPrintWalk(N, L(irNode), &buf[n0], bufferLength, astNodeStrings);
	n1 = irPassDotAstPrintWalk(N, R(irNode), &buf[n0], bufferLength-n0, astNodeStrings);

	/*
	 *	Only process nodes once.
	 */
	if (irNode->nodeColor & kNoisyIrNodeColorDotBackendColoring)
	{
    assert(astNodeStrings[irNode->type] != NULL);
		n2 = irPassDotAstDotFmt(N, &buf[n0+n1], bufferLength-(n0+n1), irNode, astNodeStrings);
		irNode->nodeColor &= ~kNoisyIrNodeColorDotBackendColoring;
	}

	return (n0+n1+n2);
}


int
irPassDotSymbolTablePrintWalk(NoisyState *  N, NoisyScope *  scope, char *  buf, int bufferLength)
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassSymbolTableDotPrintWalk);

	int	n0 = 0, n1 = 0, n2 = 0;

	if (scope == NULL)
	{
		return 0;
	}

	NoisyScope *	tmp = scope->firstChild;
	while (tmp != NULL)
	{
		n0 += irPassDotSymbolTablePrintWalk(N, tmp, &buf[n0], (bufferLength-n0));
		tmp = tmp->next;
	}

	/*
	 *	Only process nodes once.
	 */
	if (scope->nodeColor & kNoisyIrNodeColorDotBackendColoring)
	{
		n1 = irPassDotSymbolTableDotFmt(N, &buf[n0], (bufferLength-n0), scope);
		scope->nodeColor &= ~kNoisyIrNodeColorDotBackendColoring;
	}

	n2 += irPassDotSymbolTablePrintWalk(N, scope->next, &buf[n0+n1], (bufferLength-(n0+n1)));

	return (n0+n1+n2);
}


char *
irPassDotBackend(NoisyState *  N, NoisyScope *  noisyIrTopScope, NoisyIrNode * noisyIrRoot, char* astNodeStrings[])
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassDotBackend);

	int			bufferLength, irAndSymbolTableSize = 0;
	char *			buf = NULL;




	/*
	 *	Heuristic
	 */
	irAndSymbolTableSize += noisyIrPassHelperIrSize(N, noisyIrRoot);
	irAndSymbolTableSize += noisyIrPassHelperSymbolTableSize(N, noisyIrTopScope);
	bufferLength = irAndSymbolTableSize*kNoisyChunkBufferLength;

	/*
	 *	This buffer is deallocated by our caller
	 */
	buf = calloc(bufferLength, sizeof(char));
	if (buf == NULL)
	{
		noisyFatal(N, Emalloc);
	}

	/*
	 *	Length is required to be 26 chars by ctime_r.
	 */
	char			dateString[26];
	struct timeval		t;
	gettimeofday(&t, NULL);
	ctime_r(&t.tv_sec, dateString);

	/*
	 *	Ctime string always ends in '\n\0'; elide the '\n'
	 */
	dateString[24] = '.';

  int n = 0;
	n += snprintf(&buf[n], bufferLength, "digraph Noisy\n{\n");
//TODO: here and elsewhere, should be taking bufferLength = max(bufferLength - n, 0)
//n = max(MAX_PRINT_BUF - strlen(buf), 0); like we do for universe_print in sal

	bufferLength -= n;

	/*
	 *	When rendering bitmapped, don't restrict size, and
	 *	leave dpi reasonable (~150).
	 */
	n += snprintf(&buf[n], bufferLength, "\tdpi=150;\n");
	bufferLength -= n;
	n += snprintf(&buf[n], bufferLength, "\tfontcolor=\"#C0C0C0\";\n");
	bufferLength -= n;
	n += snprintf(&buf[n], bufferLength, "\tfontsize=18;\n");
	bufferLength -= n;

//TODO: take the whole of this following string as one of the arguments, called, e.g., "dotplotlabel",
//so we are not calling gettimeofday() from here, and don't need to have the VM_VERSION symbol here either.
	n += snprintf(&buf[n], bufferLength, "\tlabel = \"\\nAuto-generated by Noisy compiler, version %s, on %s\";\n",
			kNewtonVersion, dateString);
	bufferLength -= n;
	n += snprintf(&buf[n], bufferLength, "\tsplines = true;\n");
	bufferLength -= n;

	/*
	 *	Don't restrict size when rendering bitmapped
	 */
	//n += snprintf(&buf[n], bufferLength, "\tsize = \"5,9\";\n");
	//bufferLength -= n;

	n += snprintf(&buf[n], bufferLength, "\tmargin = 0.1;\n");
	bufferLength -= n;

	/*
	 *	Temporarily color the graph, so we can know
	 *	which nodes have been visited, in case when
	 *	the graph is not a tree.
	 */
	noisyIrPassHelperColorIr(N, noisyIrRoot, kNoisyIrNodeColorDotBackendColoring, true/* set */, true/* recurse flag */);
	noisyIrPassHelperColorSymbolTable(N, noisyIrTopScope, kNoisyIrNodeColorDotBackendColoring, true/* set */, true/* recurse flag */);

	n += irPassDotAstPrintWalk(N, noisyIrRoot, &buf[n], bufferLength, astNodeStrings);
	bufferLength -= n;

	n += irPassDotSymbolTablePrintWalk(N, noisyIrTopScope, &buf[n], bufferLength);
	bufferLength -= n;

	n += snprintf(&buf[n], bufferLength, "}\n");
	bufferLength -= n;
	USED(bufferLength);

	/*
	 *	TODO: this is not really necessary, since we now use individual
	 *	bitfields for coloring in different passes, and we clear the
	 *	colors of nodes above anyway. If/when we decide to get rid of
	 *	this, be sure to document the associated gain.
	 */
	noisyIrPassHelperColorIr(N, noisyIrRoot, ~kNoisyIrNodeColorDotBackendColoring, false/* clear */, true/* recurse flag */);
	noisyIrPassHelperColorSymbolTable(N, noisyIrTopScope, ~kNoisyIrNodeColorDotBackendColoring, false/* clear */, true/* recurse flag */);

	return buf;
}






/*
 *	Local functions.
 */




static char *
scope2id(NoisyState *  N, NoisyScope *  scope)
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassDotScope2Id);

	if (scope == NULL)
	{
		noisyFatal(N, Esanity);
	}
	if (scope->begin == NULL || scope->end == NULL)
	{
		return "???";
	}

	char *	buf, tmp[kNoisyMaxBufferLength];

	int length = snprintf(tmp, kNoisyMaxBufferLength, "%llu_%llu_%llu_%llu",
			scope->begin->lineNumber, scope->begin->columnNumber,
			scope->end->lineNumber, scope->end->columnNumber);

	buf = (char *)malloc(length);

	sprintf(buf, "%llu_%llu_%llu_%llu",
			scope->begin->lineNumber, scope->begin->columnNumber,
			scope->end->lineNumber, scope->end->columnNumber);

	return buf;
}


static char *
scope2id2(NoisyState *  N, NoisyScope *  scope)
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassDotScope2Id2);

	if (scope == NULL)
	{
		noisyFatal(N, Esanity);
	}
	if (scope->begin == NULL || scope->end == NULL)
	{
		return "???";
	}

	char *	buf, tmp[kNoisyMaxBufferLength];

	int length = snprintf(tmp, kNoisyMaxBufferLength, "%s:%llu,%llu \\nto\\n %s:%llu,%llu",
		scope->begin->fileName, scope->begin->lineNumber, 
		scope->begin->columnNumber,  scope->begin->fileName,
		scope->end->lineNumber, scope->end->columnNumber);

	buf = (char *)malloc(length);

	sprintf(buf, "%s:%llu,%llu \\nto\\n %s:%llu,%llu",
		scope->begin->fileName, scope->begin->lineNumber, 
		scope->begin->columnNumber,  scope->begin->fileName,
		scope->end->lineNumber, scope->end->columnNumber);

	return buf;
}


static char *
symbol2id(NoisyState *  N, NoisySymbol *  symbol)
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassDotSymbol2Id);

	if (symbol == NULL)
	{
		noisyFatal(N, Esanity);
	}
	if (symbol->sourceInfo == NULL)
	{
		return "???";
	}

	char *	buf, tmp[kNoisyMaxBufferLength];

	int length = snprintf(tmp, kNoisyMaxBufferLength, "%llu_%llu",
		symbol->sourceInfo->lineNumber, symbol->sourceInfo->columnNumber);

	buf = (char *)malloc(length);

	sprintf(buf, "%llu_%llu",
		symbol->sourceInfo->lineNumber, symbol->sourceInfo->columnNumber);

	return buf;

}


static bool
isType(NoisyState *  N, NoisyIrNode *  node)
{
	NoisyTimeStampTraceMacro(kNoisyTimeStampKeyIrPassDotIsType);

	switch (node->type)
    {
		case    kNewtonIrNodeType_Tlt:
		case    kNewtonIrNodeType_Tle:
		case    kNewtonIrNodeType_Tgt:
		case    kNewtonIrNodeType_Tge:
		case    kNewtonIrNodeType_Tproportionality:
		case    kNewtonIrNodeType_Tequivalent:
		case    kNewtonIrNodeType_Tsemicolon:
		case    kNewtonIrNodeType_Tcolon:
		case    kNewtonIrNodeType_Tcomma:
		case    kNewtonIrNodeType_Tdot:
		case	kNewtonIrNodeType_Tdiv:
		case	kNewtonIrNodeType_Tmul:
		case	kNewtonIrNodeType_Tplus:
		case	kNewtonIrNodeType_Tminus:
		case    kNewtonIrNodeType_Texponent:
		case	kNewtonIrNodeType_Tequals:
		case    kNewtonIrNodeType_TintConst:
		case    kNewtonIrNodeType_TrealConst:	
		case	kNewtonIrNodeType_TstringConst:
		case	kNewtonIrNodeType_Tcross:
		case	kNewtonIrNodeType_Tintegral:
		case	kNewtonIrNodeType_Tderivative:
		case	kNewtonIrNodeType_TSpanish:
		case	kNewtonIrNodeType_TEnglish:
		case	kNewtonIrNodeType_Tinvariant:
		case	kNewtonIrNodeType_Tconstant:
		case	kNewtonIrNodeType_Tsignal:
		case	kNewtonIrNodeType_Tderivation:
		case	kNewtonIrNodeType_Tsymbol:
		case	kNewtonIrNodeType_Tname:
		case	kNewtonIrNodeType_Pinteger:
		case	kNewtonIrNodeType_Tnumber:
		case	kNewtonIrNodeType_TrightBrace:
		case	kNewtonIrNodeType_TleftBrace:
		case	kNewtonIrNodeType_TrightParen:
		case	kNewtonIrNodeType_TleftParen:
		case	kNewtonIrNodeType_Tidentifier:
		case    kNewtonIrNodeType_PlanguageSetting:
		case	kNewtonIrNodeType_PcompareOp:
		case	kNewtonIrNodeType_PvectorOp:
		case	kNewtonIrNodeType_PhighPrecedenceBinaryOp:
		case	kNewtonIrNodeType_PmidPrecedenceBinaryOp:
		case	kNewtonIrNodeType_PlowPrecedenceBinaryOp:
		case	kNewtonIrNodeType_PunaryOp:
		case	kNewtonIrNodeType_PtimeOp:
		case	kNewtonIrNodeType_Pquantity:
		case	kNewtonIrNodeType_PquantityFactor:
		case	kNewtonIrNodeType_PquantityTerm:
		case	kNewtonIrNodeType_PquantityExpression:
		case	kNewtonIrNodeType_Pparameter:
		case	kNewtonIrNodeType_PparameterTuple:
		case	kNewtonIrNodeType_Pderivation:
		case	kNewtonIrNodeType_Psymbol:
		case	kNewtonIrNodeType_Pname:
		case	kNewtonIrNodeType_Pconstraint:
		case	kNewtonIrNodeType_PconstraintList:
		case	kNewtonIrNodeType_PbaseSignal:
		case	kNewtonIrNodeType_Pinvariant:
		case	kNewtonIrNodeType_Pconstant:
		case	kNewtonIrNodeType_Prule:
		case	kNewtonIrNodeType_PruleList:
		case	kNewtonIrNodeType_PnewtonFile:
      {
        return true;
      }

		default:
      {
        return false;
      }
    }

	return false;
}
