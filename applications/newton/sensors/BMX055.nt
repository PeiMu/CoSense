#
#       Authored 2018, Phillip Stanley-Marbell.
#
#       All rights reserved.
#
#       Redistribution and use in source and binary forms, with or without
#       modification, are permitted provided that the following conditions
#       are met:
#
#       *       Redistributions of source code must retain the above
#               copyright notice, this list of conditions and the following
#               disclaimer.
#
#       *       Redistributions in binary form must reproduce the above
#               copyright notice, this list of conditions and the following
#               disclaimer in the documentation and/or other materials
#               provided with the distribution.
#
#       *       Neither the name of the author nor the names of its
#               contributors may be used to endorse or promote products
#               derived from this software without specific prior written
#               permission.
#
#       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#       "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#       LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#       FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
#       COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#       INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#       BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#       LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#       CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#       LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
#       ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#       POSSIBILITY OF SUCH DAMAGE.
#
#
#       Description: Base signals used in most Newton descriptions.
#

time : signal =
{
        name            = "second" English;
        symbol          = "s";
        derivation      = none;
}

distance : signal =
{
        name            = "meter" English;
        symbol          = "m";
        derivation      = none;
}

mass : signal =
{
        name            = "kilogram" English;
        symbol          = "kg";
        derivation      = none;
}

material : signal =
{
        name            = "mole" English;
        symbol          = "mol";
        derivation      = none;
}

temperature : signal =
{
        name            = "Kelvin" English;
        symbol          = "K";
        derivation      = none;
}

charge : signal =
{
        name            = "Coulomb" English;
        symbol          = "C";
        derivation      = none;
}

angle : signal =
{
        name            = "degree" English;
        symbol          = "deg";
        derivation      = distance / distance;
}

speed : signal =
{
        name            = "jiffies" English;
        symbol          = "jf";
        derivation      = distance / time;
}

acceleration : signal =
{
        name            = "metajiffies" English;
        symbol          = "mj";
        derivation      = speed / time;
}


force : signal =
{
        name            = "Newton" English;
        symbol          = "N";
        derivation      = mass * acceleration;
}

work : signal = 
{
        name            = "Joule" English;
        symbol          = "J";
        derivation      = force * distance;
}

magneticFluxDensity : signal =
{
        name            = "Tesla" English;
        symbol          = "T";
        derivation      = mass / (charge * time);
}

angularRate : signal =
{
        name            = "anglejiffies" English;
        symbol          = "aj";
        derivation      = angle / time;
}

frequency : signal =
{
        name            = "Hertz" English;
        symbol          = "Hz";
        derivation      = 1 / time;
}

area : signal =
{
        name            = "squares" English;
        symbol          = "sq";
        derivation      = distance ** 2;
}

pressure : signal =
{
        name            = "Pascal" English;
        symbol          = "Pa";
        derivation      = force / area;
}

kNewtonUnitfree_pi                              : constant = 3.1415926535897932384626433832795;

#
#       The data below are from Mathematica Version 9's PhysicalConstants comunity-created package.
#
kNewtonUnithave_SpeedOfLight                    : constant = 299792458 * meter * second ** -1;
kNewtonUnithave_AccelerationDueToGravity        : constant = (196133 / 20000) * meter * second ** -2;
kNewtonUnithave_GravitationalConstant           : constant = 6.67428E-11 * meter ** 3 * kilogram ** -1 * second ** -2;
kNewtonUnithave_AvogadroConstant                : constant = 6.02214E23 * mole;
kNewtonUnithave_BoltzmannConstant               : constant = 1.38065E-23 * Joule / Kelvin;
kNewtonUnithave_ElectronCharge                  : constant = 1.60218E-19 * Coulomb;
kNewtonUnithave_SpeedOfSound                    : constant = 340.292 * meter * second ** -1;
kNewtonUnithave_EarthMass                       : constant = 5.9742E24 * kilogram;

#
#		Description: Additional signals used in this particular newton description.
#

noise : signal =
{
	name = "micro g per square root of Hertz" English;
	symbol = "n";
	derivation = (10 ** -6) * acceleration / (frequency ** 0.5);
}

microMagneticFluxDensity : signal =
{
	name = "micro Tesla" English;
	symbol = "b";
	derivation = (10 ** -6) * magneticFluxDensity;
}

#
#		Newton Description for the sensor BMX055 starts here
#
#		Figures quoted here are referenced from Bosch BMX055 Sensor Module data sheet revision 1.0
#
#		The constant is a value which can never be generated by the sensor. We use that to denote “impossible” or “invalid” readings. 
#  

kBMX055xAccelerationErasureToken: const = 16rFEFE;
kBMX055yAccelerationErasureToken: const = 16rFEFE;
kBMX055zAccelerationErasureToken: const = 16rFEFE;
kBMX055TemperatureErasureToken: const = 16rFEFE;

kBMX055xmicroMagneticFluxDensityErasureToken: const = 16rFEFE;
kBMX055ymicroMagneticFluxDensityErasureToken: const = 16rFEFE;
kBMX055zmicroMagneticFluxDensityErasureToken: const = 16rFEFE;

kBMX055xAngularRateErasureToken: const = 16rFEFE;
kBMX055yAngularRateErasureToken: const = 16rFEFE;
kBMX055zAngularRateErasureToken: const = 16rFEFE;

#
#		Standard Deviation not available in data sheet.
#  

kBMX055xAccelerationStdev: const = ; 
kBMX055yAccelerationStdev: const = ; 
kBMX055zAccelerationStdev: const = ; 
kBMX055TemperatureStdev: const = ; 

kBMX055xmicroMagneticFluxDensityStdev: const = ; 
kBMX055ymicroMagneticFluxDensityStdev: const = ; 
kBMX055zmicroMagneticFluxDensityStdev: const = ; 

kBMX055xAngularRateStdev: const = ; 
kBMX055yAngularRateStdev: const = ; 
kBMX055zAngularRateStdev: const = ; 

bmx055: sensor (
			xAccel: acceleration@0,
			yAccel: acceleration@1,		
			zAccel: acceleration@2,
			Temp: temperature,	
						
			xmicroMagneto: microMagneticFluxDensity@0,	
			ymicroMagneto: microMagneticFluxDensity@1,	
			zmicroMagneto: microMagneticFluxDensity@2,	
					
			xAngularRate: angularRate@0,
			yAngularRate: angularRate@1,	
			zAngularRate: angularRate@2
				)
{

	#
	#		The full range of the sensor
	#
	#		Range of Acceleration can be found in Table 2 on page 11
	#
	
	range xAcceleration == [-16*mj .. 16*mj],
	range yAcceleration == [-16*mj .. 16*mj],
	range zAcceleration == [-16*mj .. 16*mj],

	#
	#		Range of Temperature can be found in Table 2 on page 11
	#

	range Temperature == [233.15*K .. 358.15*K],
        
	#
	#		Range of micro Magnetic Field Density can be found in Table 4 on page 17
	#
	
	range xmicroMagneticFluxDensity == [-1300*b .. 1300*b],
    range ymicroMagneticFluxDensity == [-1300*b .. 1300*b],
    range zmicroMagneticFluxDensity == [-2500*b .. 2500*b],

	#
	#		Range of Angular Rate can be found in Table 3 on page 14
	#
	
	range xAngularRate == [0*aj .. 2000*aj],
    range yAngularRate == [0*aj .. 2000*aj],
    range zAngularRate == [0*aj .. 2000*aj],	
	
	#
	#		The operation sequence needed to get a sample
	#
	#		i2c address of Accelerometer can be found in Table 64 on page 145
	#
	#		Register address of Accelerometer can be found in Figure 12 of document 6.2 on page 49
	#

	interface xAcceleration == "i2c" (address: "0x18")
	{

		#
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#		Get MSB and LSB of xAccel data...
		#
		
		xAccelHigh = read 16r03;
		xAccelLow = read 16r02;
		xAcceleration = (xAccelHigh << 4) | (xAccelLow >> 4);
	},

	interface yAcceleration == "i2c" (address: "0x18")
	{

		#
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#		Get MSB and LSB of yAccel data...
		#	
		
		yAccelHigh = read 16r05;
		yAccelLow = read 16r04;
		yAcceleration = (yAccelHigh << 4) | (yAccelLow >> 4);
	},

	interface zAcceleration == "i2c" (address: "0x18")
	{		
	
		#
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#		Get MSB and LSB of zAccel data...
		#
			
		zAccelHigh = read 16r07;
		zAccelLow = read 16r06;
		zAcceleration = (zAccelHigh << 4) | (zAccelLow >> 4);
	},

	#
	#		Temperature sensor is part of the accelerometer so i2c address of Temperature Sensor is also 0x18
	#
	#		Register address of temperature sensor can be found in Figure 12 of document 6.2 on page 49
	#

	interface Temperature == "i2c" (address: "0x18")
	{
	
		#		
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#	
		#		Get Temp data...
		#
				
		Temperature = read 16r08;
	},

	#
	#		i2c address of Magnetometer can be found in Table 64 on page 145
	#
	#		Register address of Magnetometer can be found in document 10.2 on page 130
	#

	interface xmicroMagneticFluxDensity == "i2c" (address: "0x10")
	{
	
		#		
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#	
		#		Get MSB and LSB of xmicroMagneto data...
		#
			
		xmicroMagnetoHigh = read 16r43;
		xmicroMagnetoLow = read 16r42;
		xmicroMagneticFluxDensity = (xmicroMagnetoHigh << 5) | (xmicroMagnetoLow >> 3);
	},

	interface ymicroMagneticFluxDensity == "i2c" (address: "0x10")
	{
		
		#
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#		Get MSB and LSB of ymicroMagneto data...
		#	
		
		ymicroMagnetoHigh = read 16r45;
		ymicroMagnetoLow = read 16r44;
		ymicroMagneticFluxDensity = (ymicroMagnetoHigh << 5) | (ymicroMagnetoLow >> 3);
	},

	interface zmicroMagneticFluxDensity == "i2c" (address: "0x10")
	{
	
		#		
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#		Get MSB and LSB of zmicroMagneto data...
		#
				
		zmicroMagnetoHigh = read 16r47;
		zmicroMagnetoLow = read 16r46;
		zmicroMagneticFluxDensity = (zmicroMagnetoHigh << 7) | (zmicroMagnetoLow >> 1);
	},

	#
	#		i2c address of Gyroscope can be found in Table 64 on page 145
	#
	#		Register address of Gyroscope can be found in Figure 19 of document 8.2 on page 92
	#

	interface xAngularRate == "i2c" (address: "0x68")
	{
	
		#	
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#		Get MSB and LSB of xAngularRate data...
		#
				
		xAngularRateHigh = read 16r03;
		xAngularRateLow = read 16r02;
		xAngularRate = (xAngularRateHigh << 8) | (xAngularRateLow);
	},

	interface yAngularRate == "i2c" (address: "0x68")
	{
	
		#
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#	
		#		Get MSB and LSB of yAngularRate data...	
		#
				
		yAngularRateHigh = read 16r05;
		yAngularRateLow = read 16r04;
		yAngularRate = (yAngularRateHigh << 8) | (yAngularRateLow);
	},

	interface zAngularRate == "i2c" (address: "0x68")

	{
		#
		#		Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#		Get MSB and LSB of zAngularRate data...
		#	
			
		zAngularRateHigh = read 16r07;
		zAngularRateLow = read 16r06;
		zAngularRate = (zAngularRateHigh << 8) | (zAngularRateLow);
	},

	#
	#		Uncertainty/noise model of the sensor as a function of mean value	
	#
	#		Unsure about the function that describes the relationship between the following variables, so leave them as they are
	#

	uncertainty xAcceleration == Gaussian(xAcceleration, kBMX055xAccelerationStdev)*g,
	uncertainty yAcceleration == Gaussian(yAcceleration, kBMX055yAccelerationStdev)*g,
	uncertainty zAcceleration == Gaussian(zAcceleration, kBMX055zAccelerationStdev)*g,
	uncertainty Temperature == Gaussian(Temperature, kBMX055TemperatureStdev)*g,

	uncertainty xmicroMagneticFluxDensity == Gaussian(xmicroMagneticFluxDensity, kBMX055xmicroMagneticFluxDensityStdev)*g,
	uncertainty ymicroMagneticFluxDensity == Gaussian(ymicroMagneticFluxDensity, kBMX055ymicroMagneticFluxDensityStdev)*g,
	uncertainty zmicroMagneticFluxDensity == Gaussian(zmicroMagneticFluxDensity, kBMX055zmicroMagneticFluxDensityStdev)*g,

	uncertainty xAngularRate == Gaussian(xAngularRate, kBMX055xAngularRateStdev)*g,
	uncertainty yAngularRate == Gaussian(yAngularRate, kBMX055yAngularRateStdev)*g,
	uncertainty zAngularRate == Gaussian(zAngularRate, kBMX055zAngularRateStdev)*g,
	
	#
	#		When this token is returned by the sensor, it denotes invalid sensed value / erasure in communication with sensor.
	#

	erasuretoken xAcceleration == kBMX055xAccelerationErasureToken,
	erasuretoken yAcceleration == kBMX055yAccelerationErasureToken,
	erasuretoken zAcceleration == kBMX055zAccelerationErasureToken,
	erasuretoken Temperature == kBMX055TemperatureErasureToken,
	
	erasuretoken xmicroMagneticFluxDensity == kBMX055xmicroMagneticFluxDensityErasureToken,
	erasuretoken ymicroMagneticFluxDensity == kBMX055ymicroMagneticFluxDensityErasureToken,
	erasuretoken zmicroMagneticFluxDensity == kBMX055zmicroMagneticFluxDensityErasureToken,

	erasuretoken xAngularRate == kBMX055xAngularRateErasureToken,
	erasuretoken yAngularRate == kBMX055yAngularRateErasureToken,
	erasuretoken zAngularRate == kBMX055zAngularRateErasureToken,
	
	#
	#		Precision settings list for the sensor. This is a list of (precision, cost) pairs
	#
	#		The cost is a power or latency (or energy=power*time) cost for accessing values. 
	#
	#		Cost has a unit of microwatts
	#
    #		Could not find the relevant information in data sheet so I left the cost as 0.
    #
	
	precision xAcceleration == {
			(12*bits, 0),
								},
	
	precision yAcceleration == {
			(12*bits, 0),
								},

	precision zAcceleration == {
			(12*bits, 0),
								},

	precision Temperature == {
			(8*bits, 0),
				 				},

	precision xmicroMagneticFluxDensity == {
			(13*bits, 0),
										},
										
	precision ymicroMagneticFluxDensity == {
			(13*bits, 0),
										},
	
	precision zmicroMagneticFluxDensity == {
			(15*bits, 0),
										},
										
	precision xAngularRate == {
			(16*bits, 0),
								},
								
	precision yAngularRate == {	
			(16*bits, 0),
								},
								
	precision zAngularRate == {
			(16*bits, 0),
								},
								
    #
	#		Accuracy settings list for the sensor. This is a list of (accuracy, cost) pairs.
	#
    #		Noise and offset values are used here for accuracy. 
    #
	#		Noise values of Accelerometer can be found in Table 2 of document 1.2 on page 12
	#
    #		Used the product of the total supply current and supply voltage in normal mode as the cost value
    #
    #		Supply voltage is 2.4 V which is stated in the footnote on page 11
	#
	#		Current values (normal mode) of Accelerometer can be found in Table 2 of document 1.2 on page 11
	#

	accuracy xAcceleration == {
				(150*n, 312),
								},

	accuracy yAcceleration == {
				(150*n, 312),
								},

	accuracy zAcceleration == {
				(150*n, 312),
								},
	
	#
	#		Offset value of Temperature Sensor can be found in Table 2 of document 1.2 on page 12
	#
    #		Used the product of the total supply current and supply voltage in normal mode as the cost value
	#
	#		Current values (normal mode) of Temperature Sensor can be found in Table 2 of document 1.2 on page 11
	#

	accuracy Temperature == {
				(4.0*K, 312),
								},

	#
	#		Noise values (normal mode with 4 different presets) of Magnetometer can be found in Table 37 of document 9.2.4 on page 122
	#
    #		Used the product of the average current consumption and supply voltage in normal mode as the cost value
    #
	#		Current values (normal mode with 4 different presets) of Magnetometer can be found in Table 37 of document 9.2.4 on page 122
	#

	accuracy xmicroMagneticFluxDensity == {		
				(1.0*b, 408),
				(0.6*b, 1200),
				(0.5*b, 1920),
				(0.3*b, 11760),
										},

	accuracy ymicroMagneticFluxDensity == {
				(1.0*b, 408),
				(0.6*b, 1200),
				(0.5*b, 1920),
				(0.3*b, 11760),
										},

	accuracy zmicroMagneticFluxDensity == {
				(1.4*b, 408),
				(0.6*b, 1200),
				(0.5*b, 1920),
				(0.3*b, 11760),
										},
					
	#
	#		Noise values of Gyroscope can be found in Table 3 of document 1.2 on page 15
	#
    #		Used the product of the total supply current and supply voltage in normal mode as the cost value
	#
	#		Current values (normal mode) of Gyroscope can be found in Table 3 of document 1.2 on page 14
	#

	accuracy xAngularRate == {
				(0.1*aj, 0.012),
								},

	accuracy xAngularRate == {
				(0.1*aj, 0.012),
								},

	accuracy xAngularRate == {
				(0.1*aj, 0.012),
								}							
}